"""AUTH_002_User_and_Audit_Log

Revision ID: 44c93726c508
Revises: 
Create Date: 2026-02-25 15:00:59.130525

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision: str = '44c93726c508'
down_revision: Union[str, Sequence[str], None] = None
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Upgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('users',
    sa.Column('id', sa.UUID(), nullable=False),
    sa.Column('email', sa.String(length=255), nullable=False),
    sa.Column('hashed_password', sa.String(length=255), nullable=False),
    sa.Column('role', sa.Enum('ADMIN', 'EDITOR', 'AUDITOR', name='userrole'), nullable=False),
    sa.Column('is_active', sa.Boolean(), nullable=False),
    sa.Column('totp_secret', sa.String(length=32), nullable=True),
    sa.Column('is_2fa_enabled', sa.Boolean(), nullable=False),
    sa.Column('failed_login_attempts', sa.Integer(), nullable=False),
    sa.Column('account_locked', sa.Boolean(), nullable=False),
    sa.Column('last_login_at', sa.DateTime(), nullable=True),
    sa.Column('created_at', sa.DateTime(), nullable=False),
    sa.Column('updated_at', sa.DateTime(), nullable=False),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_users_email'), 'users', ['email'], unique=True)
    op.create_table('audit_logs',
    sa.Column('id', sa.UUID(), nullable=False),
    sa.Column('event_type', sa.String(length=100), nullable=False),
    sa.Column('user_id', sa.UUID(), nullable=True),
    sa.Column('module', sa.String(length=100), nullable=False),
    sa.Column('description', sa.String(length=255), nullable=False),
    sa.Column('timestamp', sa.DateTime(), nullable=False),
    sa.Column('ip_address', sa.String(length=45), nullable=True),
    sa.Column('details', sa.JSON(), nullable=True),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.drop_index(op.f('idx_wt_workflow_from'), table_name='workflow_transitions')
    op.drop_table('workflow_transitions')
    op.drop_index(op.f('idx_rdim_attribute'), table_name='report_dimensions', postgresql_where='(attribute_id IS NOT NULL)')
    op.drop_index(op.f('idx_rdim_report'), table_name='report_dimensions')
    op.drop_table('report_dimensions')
    op.drop_index(op.f('idx_pel_policy_record'), table_name='policy_evaluation_log')
    op.drop_index(op.f('idx_pel_record'), table_name='policy_evaluation_log')
    op.drop_table('policy_evaluation_log')
    op.drop_table('plugin_registry')
    op.drop_index(op.f('idx_at_model'), table_name='ai_tasks')
    op.drop_index(op.f('idx_at_queued'), table_name='ai_tasks', postgresql_where='(completed_at IS NULL)')
    op.drop_index(op.f('idx_at_source_record'), table_name='ai_tasks', postgresql_where='(source_record_id IS NOT NULL)')
    op.drop_index(op.f('idx_at_workflow_instance'), table_name='ai_tasks', postgresql_where='(workflow_instance_id IS NOT NULL)')
    op.drop_table('ai_tasks')
    op.drop_index(op.f('idx_paction_policy'), table_name='policy_actions')
    op.drop_table('policy_actions')
    op.drop_table('cbe_quorum_signatures')
    op.drop_index(op.f('idx_eav_attribute_record'), table_name='entity_attribute_values')
    op.drop_index(op.f('idx_eav_record'), table_name='entity_attribute_values')
    op.drop_table('entity_attribute_values')
    op.drop_index(op.f('idx_menu_items_nav'), table_name='menu_items')
    op.drop_table('menu_items')
    op.drop_index(op.f('idx_sel_actor'), table_name='security_event_log', postgresql_where='(actor_id IS NOT NULL)')
    op.drop_index(op.f('idx_sel_event_type'), table_name='security_event_log')
    op.drop_index(op.f('idx_sel_policy'), table_name='security_event_log', postgresql_where='(policy_id IS NOT NULL)')
    op.drop_index(op.f('idx_sel_session'), table_name='security_event_log', postgresql_where='(session_id IS NOT NULL)')
    op.drop_index(op.f('idx_sel_severity'), table_name='security_event_log', postgresql_where="(severity = ANY (ARRAY['WARN'::text, 'ERROR'::text, 'CRITICAL'::text]))")
    op.drop_table('security_event_log')
    op.drop_index(op.f('idx_rra_report_role'), table_name='report_role_access')
    op.drop_index(op.f('idx_rra_role'), table_name='report_role_access')
    op.drop_table('report_role_access')
    op.drop_table('tenant_settings')
    op.drop_table('residency_violation_log')
    op.drop_table('chain_break_events')
    op.drop_table('tenant_shard_config')
    op.drop_index(op.f('idx_rf_report'), table_name='report_filters')
    op.drop_index(op.f('idx_rf_user_facing'), table_name='report_filters', postgresql_where='(is_user_facing = true)')
    op.drop_table('report_filters')
    op.drop_index(op.f('idx_pel_exit'), table_name='plugin_execution_log')
    op.drop_index(op.f('idx_pel_plugin'), table_name='plugin_execution_log')
    op.drop_table('plugin_execution_log')
    op.drop_table('audit_tenant_sequence')
    op.drop_table('sovereign_admin_registry')
    op.drop_index(op.f('idx_form_fields_section'), table_name='form_fields')
    op.drop_table('form_fields')
    op.drop_table('policy_action_map')
    op.drop_table('menu_master')
    op.drop_index(op.f('idx_rm_entity'), table_name='report_master')
    op.drop_index(op.f('idx_rm_system_templates'), table_name='report_master', postgresql_where='(tenant_id IS NULL)')
    op.drop_index(op.f('idx_rm_tenant_category'), table_name='report_master')
    op.drop_index(op.f('uq_report_code_system'), table_name='report_master', postgresql_where='(tenant_id IS NULL)')
    op.drop_table('report_master')
    op.drop_index(op.f('idx_aql_tenant_window'), table_name='api_quota_ledger')
    op.drop_table('api_quota_ledger')
    op.drop_index(op.f('idx_form_submissions_form'), table_name='form_submissions')
    op.drop_index(op.f('idx_form_submissions_user'), table_name='form_submissions')
    op.drop_table('form_submissions')
    op.drop_index(op.f('idx_wis_record'), table_name='workflow_instance_state')
    op.drop_index(op.f('idx_wis_sla'), table_name='workflow_instance_state', postgresql_where='(sla_deadline IS NOT NULL)')
    op.drop_index(op.f('idx_wis_workflow_state'), table_name='workflow_instance_state')
    op.drop_table('workflow_instance_state')
    op.drop_table('ai_capability_master')
    op.drop_table('workflow_states')
    op.drop_index(op.f('idx_ass_audit_log'), table_name='audit_state_snapshot')
    op.drop_index(op.f('idx_ass_record'), table_name='audit_state_snapshot')
    op.drop_table('audit_state_snapshot')
    op.drop_index(op.f('idx_wsl_record'), table_name='workflow_state_log')
    op.drop_table('workflow_state_log')
    op.drop_index(op.f('idx_rmeas_report'), table_name='report_measures')
    op.drop_table('report_measures')
    op.drop_index(op.f('idx_er_active'), table_name='entity_records', postgresql_where='(deleted_at IS NULL)')
    op.drop_index(op.f('idx_er_created'), table_name='entity_records')
    op.drop_index(op.f('idx_er_entity'), table_name='entity_records')
    op.drop_table('entity_records')
    op.drop_index(op.f('idx_eavh_record'), table_name='entity_attribute_value_history')
    op.drop_index(op.f('idx_eavh_value'), table_name='entity_attribute_value_history')
    op.drop_table('entity_attribute_value_history')
    op.drop_index(op.f('idx_policy_entity'), table_name='policy_master')
    op.drop_table('policy_master')
    op.drop_table('tenants')
    op.drop_index(op.f('idx_entity_master_type'), table_name='entity_master')
    op.drop_table('entity_master')
    op.drop_index(op.f('idx_tam_category_window'), table_name='tenant_activity_metrics')
    op.drop_index(op.f('idx_tam_scope'), table_name='tenant_activity_metrics', postgresql_where='(scope_ref_id IS NOT NULL)')
    op.drop_table('tenant_activity_metrics')
    op.drop_index(op.f('idx_ai_model_default'), table_name='ai_model_registry', postgresql_where='(is_default = true)')
    op.drop_index(op.f('idx_ai_model_type'), table_name='ai_model_registry')
    op.drop_table('ai_model_registry')
    op.drop_index(op.f('idx_cam_tenant_date'), table_name='cold_archive_manifest')
    op.drop_index(op.f('idx_cam_type'), table_name='cold_archive_manifest')
    op.drop_table('cold_archive_manifest')
    op.drop_index(op.f('idx_pcond_attribute'), table_name='policy_conditions', postgresql_where='(attribute_id IS NOT NULL)')
    op.drop_index(op.f('idx_pcond_policy'), table_name='policy_conditions')
    op.drop_table('policy_conditions')
    op.drop_index(op.f('idx_form_entity'), table_name='form_master')
    op.drop_table('form_master')
    op.drop_index(op.f('idx_eri_attribute_num'), table_name='entity_record_index', postgresql_where='(index_value_num IS NOT NULL)')
    op.drop_index(op.f('idx_eri_attribute_value'), table_name='entity_record_index')
    op.drop_index(op.f('idx_eri_fts'), table_name='entity_record_index', postgresql_using='gin', postgresql_where='(tsvector_value IS NOT NULL)')
    op.drop_index(op.f('idx_eri_tenant_entity'), table_name='entity_record_index')
    op.drop_table('entity_record_index')
    op.drop_index(op.f('idx_attribute_values_record'), table_name='attribute_values')
    op.drop_table('attribute_values')
    op.drop_index(op.f('idx_ael_actor'), table_name='audit_event_log')
    op.drop_index(op.f('idx_ael_event_type'), table_name='audit_event_log')
    op.drop_index(op.f('idx_ael_logged_at'), table_name='audit_event_log')
    op.drop_index(op.f('idx_ael_record'), table_name='audit_event_log', postgresql_where='(record_id IS NOT NULL)')
    op.drop_index(op.f('idx_ael_tenant_seq'), table_name='audit_event_log')
    op.drop_table('audit_event_log')
    op.drop_table('circuit_breaker_log')
    op.drop_index(op.f('idx_er_subject'), table_name='erasure_requests')
    op.drop_table('erasure_requests')
    op.drop_table('ai_user_preferences')
    op.drop_index(op.f('idx_attribute_master_entity'), table_name='attribute_master')
    op.drop_table('attribute_master')
    op.drop_index(op.f('idx_workflow_entity'), table_name='workflow_master')
    op.drop_table('workflow_master')
    op.drop_table('ai_role_access')
    op.drop_index(op.f('idx_rel_actor'), table_name='report_execution_log', postgresql_where='(actor_id IS NOT NULL)')
    op.drop_index(op.f('idx_rel_errors'), table_name='report_execution_log', postgresql_where='(error_code IS NOT NULL)')
    op.drop_index(op.f('idx_rel_executed'), table_name='report_execution_log')
    op.drop_index(op.f('idx_rel_exports'), table_name='report_execution_log', postgresql_where='(was_exported = true)')
    op.drop_index(op.f('idx_rel_report'), table_name='report_execution_log')
    op.drop_table('report_execution_log')
    op.drop_table('dashboard_widgets')
    op.drop_table('ai_execution_log')
    op.drop_table('form_submission_audit_log')
    op.drop_table('workflow_transition_rules')
    op.drop_index(op.f('idx_form_sections_form'), table_name='form_sections')
    op.drop_table('form_sections')
    op.drop_index(op.f('idx_lhr_subject'), table_name='legal_hold_registry', postgresql_where='(lifted_at IS NULL)')
    op.drop_table('legal_hold_registry')
    op.drop_index(op.f('idx_ss_category_key'), table_name='system_settings')
    op.drop_index(op.f('idx_ss_scope'), table_name='system_settings')
    op.drop_index(op.f('idx_ss_scope_ref'), table_name='system_settings', postgresql_where='(scope_ref_id IS NOT NULL)')
    op.drop_table('system_settings')
    op.drop_table('tenant_audit_log')
    # ### end Alembic commands ###


def downgrade() -> None:
    """Downgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('tenant_audit_log',
    sa.Column('tenant_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('log_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.Column('actor_id', sa.UUID(), autoincrement=False, nullable=True, comment='UUID of the user or service account that triggered the action.'),
    sa.Column('action', sa.TEXT(), autoincrement=False, nullable=False, comment='Descriptor string for the event (SCREAMING_SNAKE_CASE convention).'),
    sa.Column('payload', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=True, comment='JSONB diff/context captured at action time. Immutable once written.'),
    sa.Column('logged_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.ForeignKeyConstraint(['tenant_id'], ['tenants.tenant_id'], name=op.f('tenant_audit_log_tenant_id_fkey'), ondelete='RESTRICT'),
    sa.PrimaryKeyConstraint('tenant_id', 'log_id', name=op.f('pk_tenant_audit_log')),
    sa.UniqueConstraint('log_id', name=op.f('uq_tenant_audit_log_id')),
    comment='INSERT-ONLY audit log for kernel-level actions. LAW 8: No UPDATE/DELETE ever.'
    )
    op.create_table('system_settings',
    sa.Column('tenant_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('setting_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.Column('setting_category', sa.TEXT(), autoincrement=False, nullable=False, comment='Domain partition: ACADEMIC | FINANCE | UI | SYSTEM | AI | INTEGRATION. Enables domain-scoped bulk reads.'),
    sa.Column('setting_key', sa.TEXT(), autoincrement=False, nullable=False, comment='Dot-namespaced key: e.g. "academic.grading.passing_threshold", "ai.default_model_code".'),
    sa.Column('setting_value', sa.TEXT(), autoincrement=False, nullable=False, comment='Plain value for non-encrypted settings. For is_encrypted=TRUE this is a secret-manager reference path, never the actual secret.'),
    sa.Column('scope_level', sa.TEXT(), autoincrement=False, nullable=False, comment='Scope tier: GLOBAL | TENANT | SCHOOL | CLASS. Narrowest matching scope wins at resolution time.'),
    sa.Column('scope_ref_id', sa.UUID(), autoincrement=False, nullable=True, comment='For SCHOOL/CLASS scope: the entity_records.record_id of the school or class. NULL for GLOBAL/TENANT.'),
    sa.Column('is_encrypted', sa.BOOLEAN(), server_default=sa.text('false'), autoincrement=False, nullable=False, comment='TRUE means setting_value is a secret-manager reference. The actual credential is NEVER stored in this column.'),
    sa.Column('description', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('version_number', sa.INTEGER(), server_default=sa.text('1'), autoincrement=False, nullable=False, comment='Optimistic concurrency stamp. Application layer must pass current version when updating to prevent lost-write races.'),
    sa.Column('is_active', sa.BOOLEAN(), server_default=sa.text('true'), autoincrement=False, nullable=False),
    sa.Column('created_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.Column('updated_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.Column('updated_by', sa.UUID(), autoincrement=False, nullable=True, comment='UUID of the actor (user or automation) that last changed this setting.'),
    sa.CheckConstraint("scope_level = ANY (ARRAY['GLOBAL'::text, 'TENANT'::text, 'SCHOOL'::text, 'CLASS'::text])", name=op.f('system_settings_scope_level_check')),
    sa.CheckConstraint("setting_category = ANY (ARRAY['ACADEMIC'::text, 'FINANCE'::text, 'FINANCIAL'::text, 'UI'::text, 'SYSTEM'::text, 'AI'::text, 'INTEGRATION'::text])", name=op.f('system_settings_setting_category_check')),
    sa.ForeignKeyConstraint(['tenant_id'], ['tenants.tenant_id'], name=op.f('system_settings_tenant_id_fkey'), ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('tenant_id', 'setting_id', name=op.f('pk_system_settings')),
    sa.UniqueConstraint('setting_id', name=op.f('uq_system_setting_id')),
    sa.UniqueConstraint('tenant_id', 'setting_key', 'scope_level', 'scope_ref_id', name=op.f('uq_system_setting_scope')),
    comment='Layer 8: Central multi-scope settings store. Implements LAW 5: Settings decide DEFAULT. Resolution hierarchy: GLOBAL < TENANT < SCHOOL < CLASS (narrowest wins).'
    )
    op.create_index(op.f('idx_ss_scope_ref'), 'system_settings', ['tenant_id', 'scope_ref_id'], unique=False, postgresql_where='(scope_ref_id IS NOT NULL)')
    op.create_index(op.f('idx_ss_scope'), 'system_settings', ['tenant_id', 'setting_key', 'scope_level', 'scope_ref_id'], unique=False)
    op.create_index(op.f('idx_ss_category_key'), 'system_settings', ['tenant_id', 'setting_category', 'setting_key'], unique=False)
    op.create_table('legal_hold_registry',
    sa.Column('tenant_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('hold_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.Column('subject_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('hold_reference', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('imposed_by', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('imposed_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.Column('lifted_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
    sa.Column('lifted_by', sa.UUID(), autoincrement=False, nullable=True),
    sa.Column('notes', sa.TEXT(), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['tenant_id'], ['tenants.tenant_id'], name=op.f('legal_hold_registry_tenant_id_fkey'), ondelete='RESTRICT'),
    sa.PrimaryKeyConstraint('tenant_id', 'hold_id', name=op.f('pk_legal_hold_registry')),
    sa.UniqueConstraint('hold_id', name=op.f('uq_hold_id')),
    comment='LAW 09-1.3: Legal hold registry. An active hold (lifted_at IS NULL) blocks the erasure workflow from reaching COMPLETED state, ensuring regulatory compliance with court orders takes precedence over erasure requests.'
    )
    op.create_index(op.f('idx_lhr_subject'), 'legal_hold_registry', ['tenant_id', 'subject_id', 'lifted_at'], unique=False, postgresql_where='(lifted_at IS NULL)')
    op.create_table('form_sections',
    sa.Column('tenant_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('section_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.Column('form_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('section_code', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('display_label', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('description', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('sort_order', sa.INTEGER(), server_default=sa.text('0'), autoincrement=False, nullable=False, comment='Rendering order within the form; lower = rendered first.'),
    sa.Column('is_collapsible', sa.BOOLEAN(), server_default=sa.text('false'), autoincrement=False, nullable=False),
    sa.Column('visibility_rule', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=True, comment='JSON Logic predicate evaluated against current form values; NULL means always visible.'),
    sa.Column('created_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.ForeignKeyConstraint(['tenant_id', 'form_id'], ['form_master.tenant_id', 'form_master.form_id'], name=op.f('fk_fs_form'), ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['tenant_id'], ['tenants.tenant_id'], name=op.f('form_sections_tenant_id_fkey'), ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('tenant_id', 'section_id', name=op.f('pk_form_sections')),
    sa.UniqueConstraint('section_id', name=op.f('uq_section_id')),
    sa.UniqueConstraint('tenant_id', 'form_id', 'section_code', name=op.f('uq_form_section_code')),
    comment='Logical groupings of form fields. Supports conditional visibility and page-layout control.'
    )
    op.create_index(op.f('idx_form_sections_form'), 'form_sections', ['tenant_id', 'form_id', 'sort_order'], unique=False)
    op.create_table('workflow_transition_rules',
    sa.Column('tenant_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('rule_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.Column('workflow_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('from_state_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('to_state_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('trigger_event', sa.TEXT(), autoincrement=False, nullable=False, comment='Event string fired by feature code; engine looks up matching edges and evaluates guards. No if(status==) in code (LAW 3).'),
    sa.Column('guard_policy_id', sa.UUID(), autoincrement=False, nullable=True, comment='Policy evaluated BEFORE the transition fires. Denial blocks the transition (LAW 4).'),
    sa.Column('guard_dsl', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=True, comment='Inline JSON Logic predicate as a quick guard without needing a full policy row.'),
    sa.Column('auto_fire_after_hours', sa.NUMERIC(), autoincrement=False, nullable=True, comment='If set, a scheduler automatically fires this transition when the entity exceeds the SLA.'),
    sa.Column('actor_roles', postgresql.ARRAY(sa.TEXT()), server_default=sa.text("'{}'::text[]"), autoincrement=False, nullable=False, comment='RBAC: array of role codes whose members may fire this event manually.'),
    sa.Column('notification_hook', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=True, comment='Structured spec for notifications on transition: {channel: "email", template_code: "approval_needed", recipients: ["REVIEWER"]}.'),
    sa.Column('sort_order', sa.INTEGER(), server_default=sa.text('0'), autoincrement=False, nullable=False),
    sa.Column('is_active', sa.BOOLEAN(), server_default=sa.text('true'), autoincrement=False, nullable=False),
    sa.Column('created_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.ForeignKeyConstraint(['tenant_id', 'from_state_id'], ['workflow_states.tenant_id', 'workflow_states.state_id'], name=op.f('fk_wtr_from_state'), ondelete='RESTRICT'),
    sa.ForeignKeyConstraint(['tenant_id', 'guard_policy_id'], ['policy_master.tenant_id', 'policy_master.policy_id'], name=op.f('fk_wtr_guard_policy'), ondelete='SET NULL'),
    sa.ForeignKeyConstraint(['tenant_id', 'to_state_id'], ['workflow_states.tenant_id', 'workflow_states.state_id'], name=op.f('fk_wtr_to_state'), ondelete='RESTRICT'),
    sa.ForeignKeyConstraint(['tenant_id', 'workflow_id'], ['workflow_master.tenant_id', 'workflow_master.workflow_id'], name=op.f('fk_wtr_workflow'), ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['tenant_id'], ['tenants.tenant_id'], name=op.f('workflow_transition_rules_tenant_id_fkey'), ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('tenant_id', 'rule_id', name=op.f('pk_workflow_transition_rules')),
    sa.UniqueConstraint('rule_id', name=op.f('uq_workflow_rule_id')),
    comment='Layer 4: Enriched transition graph edges. Extends Layer 2 workflow_transitions with typed state FKs, DSL guards, SLA auto-fire, and notification hooks.'
    )
    op.create_table('form_submission_audit_log',
    sa.Column('tenant_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('log_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.Column('submission_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('actor_id', sa.UUID(), autoincrement=False, nullable=True),
    sa.Column('action', sa.TEXT(), autoincrement=False, nullable=False, comment='Screaming-snake descriptor of the event (SUBMITTED | REVIEWED | APPROVED | FLAGGED | REOPENED).'),
    sa.Column('payload', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=True, comment='Snapshot of relevant state at the time of the action.'),
    sa.Column('logged_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.ForeignKeyConstraint(['tenant_id', 'submission_id'], ['form_submissions.tenant_id', 'form_submissions.submission_id'], name=op.f('fk_fsal_submission'), ondelete='RESTRICT'),
    sa.ForeignKeyConstraint(['tenant_id'], ['tenants.tenant_id'], name=op.f('form_submission_audit_log_tenant_id_fkey'), ondelete='RESTRICT'),
    sa.PrimaryKeyConstraint('tenant_id', 'log_id', name=op.f('pk_form_submission_audit_log')),
    sa.UniqueConstraint('log_id', name=op.f('uq_form_submission_log_id')),
    comment='LAW 8: INSERT-ONLY audit trail for every action taken on a form submission.'
    )
    op.create_table('ai_execution_log',
    sa.Column('tenant_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('log_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.Column('tenant_sequence_number', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('capability_id', sa.UUID(), autoincrement=False, nullable=True),
    sa.Column('actor_id', sa.UUID(), autoincrement=False, nullable=True),
    sa.Column('model_version', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('input_hash', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('output_hash', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('confidence_score', sa.NUMERIC(precision=5, scale=4), autoincrement=False, nullable=True),
    sa.Column('decision_reason_code', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('execution_data', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=False),
    sa.Column('previous_hash', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('current_hash', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('logged_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.ForeignKeyConstraint(['tenant_id', 'capability_id'], ['ai_capability_master.tenant_id', 'ai_capability_master.capability_id'], name=op.f('fk_ael_capability'), ondelete='SET NULL'),
    sa.ForeignKeyConstraint(['tenant_id'], ['tenants.tenant_id'], name=op.f('ai_execution_log_tenant_id_fkey'), ondelete='RESTRICT'),
    sa.PrimaryKeyConstraint('tenant_id', 'log_id', name=op.f('pk_ai_execution_log'))
    )
    op.create_table('dashboard_widgets',
    sa.Column('tenant_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('widget_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.Column('widget_code', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('display_name', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('metric_type', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('icon_name', sa.TEXT(), server_default=sa.text("'Activity'::text"), autoincrement=False, nullable=True),
    sa.Column('color_scheme', sa.TEXT(), server_default=sa.text("'gold'::text"), autoincrement=False, nullable=True),
    sa.Column('query_logic', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=False),
    sa.Column('sort_order', sa.INTEGER(), server_default=sa.text('0'), autoincrement=False, nullable=True),
    sa.Column('is_active', sa.BOOLEAN(), server_default=sa.text('true'), autoincrement=False, nullable=True),
    sa.Column('created_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['tenant_id'], ['tenants.tenant_id'], name=op.f('dashboard_widgets_tenant_id_fkey'), ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('widget_id', name=op.f('dashboard_widgets_pkey')),
    sa.UniqueConstraint('tenant_id', 'widget_code', name=op.f('dashboard_widgets_tenant_id_widget_code_key'))
    )
    op.create_table('report_execution_log',
    sa.Column('tenant_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('execution_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.Column('report_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('actor_id', sa.UUID(), autoincrement=False, nullable=True, comment='UUID of the triggering user/service. NULL for scheduled/system runs.'),
    sa.Column('actor_role_code', sa.TEXT(), autoincrement=False, nullable=True, comment='Role held by actor at execution time. Denormalised for forensic audit (roles may change after the fact).'),
    sa.Column('execution_mode', sa.TEXT(), server_default=sa.text("'INTERACTIVE'::text"), autoincrement=False, nullable=False, comment='How the run was triggered: INTERACTIVE | SCHEDULED | API | SYSTEM.'),
    sa.Column('applied_filters', postgresql.JSONB(astext_type=sa.Text()), server_default=sa.text("'{}'::jsonb"), autoincrement=False, nullable=False, comment='Runtime filter snapshot: {"filter_id": ..., "attribute_code": ..., "value": ...}. Immutable after insert.'),
    sa.Column('row_count', sa.BIGINT(), server_default=sa.text('0'), autoincrement=False, nullable=False, comment='Number of result rows returned. Compared with max_rows to determine was_truncated.'),
    sa.Column('was_truncated', sa.BOOLEAN(), server_default=sa.text('false'), autoincrement=False, nullable=False, comment='TRUE when row_count reached max_rows ??? the engine enforced its safety LIMIT.'),
    sa.Column('was_exported', sa.BOOLEAN(), server_default=sa.text('false'), autoincrement=False, nullable=False, comment='TRUE when the actor downloaded the result as a file.'),
    sa.Column('export_format', sa.TEXT(), autoincrement=False, nullable=True, comment='Download format used: CSV | XLSX | PDF | JSON. NULL when was_exported = FALSE.'),
    sa.Column('execution_duration_ms', sa.BIGINT(), autoincrement=False, nullable=True, comment='Wall-clock query runtime in milliseconds. Used for performance analytics and SLA monitoring.'),
    sa.Column('query_hash', sa.TEXT(), autoincrement=False, nullable=True, comment='SHA-256 of the resolved query. Never the query text itself (LAW 9). Used for caching analytics and deduplication.'),
    sa.Column('error_code', sa.TEXT(), autoincrement=False, nullable=True, comment='Machine-readable failure code: TIMEOUT | PERMISSION_DENIED | FILTER_MISSING | INTERNAL_ERROR. NULL on success.'),
    sa.Column('error_message', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('executed_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.CheckConstraint("execution_mode = ANY (ARRAY['INTERACTIVE'::text, 'SCHEDULED'::text, 'API'::text, 'SYSTEM'::text])", name=op.f('report_execution_log_execution_mode_check')),
    sa.CheckConstraint("export_format = ANY (ARRAY['CSV'::text, 'XLSX'::text, 'PDF'::text, 'JSON'::text, NULL::text])", name=op.f('report_execution_log_export_format_check')),
    sa.ForeignKeyConstraint(['report_id'], ['report_master.report_id'], name=op.f('fk_rel_report'), ondelete='RESTRICT'),
    sa.ForeignKeyConstraint(['tenant_id'], ['tenants.tenant_id'], name=op.f('report_execution_log_tenant_id_fkey'), ondelete='RESTRICT'),
    sa.PrimaryKeyConstraint('tenant_id', 'execution_id', name=op.f('pk_report_execution_log')),
    sa.UniqueConstraint('execution_id', name=op.f('uq_report_execution_id')),
    comment='Layer 10 / LAW 8: INSERT-ONLY execution audit for every report run. Captures who, when, what filters, row count, and export status. Immutable ??? trigger blocked + app_role INSERT-only.'
    )
    op.create_index(op.f('idx_rel_report'), 'report_execution_log', ['tenant_id', 'report_id', sa.literal_column('executed_at DESC')], unique=False)
    op.create_index(op.f('idx_rel_exports'), 'report_execution_log', ['tenant_id', 'report_id', 'was_exported'], unique=False, postgresql_where='(was_exported = true)')
    op.create_index(op.f('idx_rel_executed'), 'report_execution_log', ['tenant_id', sa.literal_column('executed_at DESC')], unique=False)
    op.create_index(op.f('idx_rel_errors'), 'report_execution_log', ['tenant_id', 'error_code', sa.literal_column('executed_at DESC')], unique=False, postgresql_where='(error_code IS NOT NULL)')
    op.create_index(op.f('idx_rel_actor'), 'report_execution_log', ['tenant_id', 'actor_id', sa.literal_column('executed_at DESC')], unique=False, postgresql_where='(actor_id IS NOT NULL)')
    op.create_table('ai_role_access',
    sa.Column('tenant_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('access_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.Column('capability_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('role_code', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('access_level', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('created_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.CheckConstraint("access_level = ANY (ARRAY['INTERACT'::text, 'DECISION_SUPPORT'::text])", name=op.f('ai_role_access_access_level_check')),
    sa.ForeignKeyConstraint(['tenant_id', 'capability_id'], ['ai_capability_master.tenant_id', 'ai_capability_master.capability_id'], name=op.f('fk_ara_capability'), ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['tenant_id'], ['tenants.tenant_id'], name=op.f('ai_role_access_tenant_id_fkey'), ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('tenant_id', 'access_id', name=op.f('pk_ai_role_access'))
    )
    op.create_table('workflow_master',
    sa.Column('tenant_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('workflow_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.Column('workflow_code', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('display_name', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('entity_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('initial_state', sa.TEXT(), autoincrement=False, nullable=False, comment='State name that new entity instances are placed into upon creation.'),
    sa.Column('is_active', sa.BOOLEAN(), server_default=sa.text('true'), autoincrement=False, nullable=False),
    sa.Column('created_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.ForeignKeyConstraint(['tenant_id', 'entity_id'], ['entity_master.tenant_id', 'entity_master.entity_id'], name=op.f('fk_workflow_entity'), ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['tenant_id'], ['tenants.tenant_id'], name=op.f('workflow_master_tenant_id_fkey'), ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('tenant_id', 'workflow_id', name=op.f('pk_workflow_master')),
    sa.UniqueConstraint('tenant_id', 'workflow_code', name=op.f('uq_workflow_code')),
    sa.UniqueConstraint('workflow_id', name=op.f('uq_workflow_id')),
    comment='LAW 3+5: Named state machine definitions. Replaces status-check conditionals in code.'
    )
    op.create_index(op.f('idx_workflow_entity'), 'workflow_master', ['tenant_id', 'entity_id'], unique=False)
    op.create_table('attribute_master',
    sa.Column('tenant_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('attribute_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.Column('entity_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('attribute_code', sa.TEXT(), autoincrement=False, nullable=False, comment='Snake-case machine identifier for the field (e.g. "date_of_birth").'),
    sa.Column('display_label', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('data_type', sa.TEXT(), autoincrement=False, nullable=False, comment='Storage type: text | number | boolean | date | json | file.'),
    sa.Column('is_required', sa.BOOLEAN(), server_default=sa.text('false'), autoincrement=False, nullable=False),
    sa.Column('is_system', sa.BOOLEAN(), server_default=sa.text('false'), autoincrement=False, nullable=False, comment='TRUE for kernel-defined attributes that tenants cannot delete.'),
    sa.Column('default_value', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('validation_rule', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=True, comment='JSON Schema fragment applied at write time (e.g. min/max, pattern).'),
    sa.Column('sort_order', sa.INTEGER(), server_default=sa.text('0'), autoincrement=False, nullable=False),
    sa.Column('created_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.Column('is_searchable', sa.BOOLEAN(), server_default=sa.text('false'), autoincrement=False, nullable=False, comment='When TRUE, written values for this attribute are synchronised into entity_record_index for fast search. Layer 6 dependency.'),
    sa.Column('pii_class', sa.TEXT(), autoincrement=False, nullable=True, comment='LAW 09-1.4: PII classification. DIRECT = name/DOB/contact (eligible for CAP tombstone). INDIRECT = derived identifiers. SENSITIVE = health/financial special category. NULL = non-PII field safe for unrestricted use.'),
    sa.CheckConstraint("pii_class = ANY (ARRAY['DIRECT'::text, 'INDIRECT'::text, 'SENSITIVE'::text])", name=op.f('attribute_master_pii_class_check')),
    sa.ForeignKeyConstraint(['tenant_id', 'entity_id'], ['entity_master.tenant_id', 'entity_master.entity_id'], name=op.f('fk_attribute_entity'), ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['tenant_id'], ['tenants.tenant_id'], name=op.f('attribute_master_tenant_id_fkey'), ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('tenant_id', 'attribute_id', name=op.f('pk_attribute_master')),
    sa.UniqueConstraint('attribute_id', name=op.f('uq_attribute_id')),
    sa.UniqueConstraint('tenant_id', 'entity_id', 'attribute_code', name=op.f('uq_attribute_code')),
    comment='LAW 2: Every dynamic field for every entity is defined here. No custom table columns allowed.'
    )
    op.create_index(op.f('idx_attribute_master_entity'), 'attribute_master', ['tenant_id', 'entity_id'], unique=False)
    op.create_table('ai_user_preferences',
    sa.Column('tenant_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('user_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('preference_key', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('preference_value', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('updated_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.ForeignKeyConstraint(['tenant_id'], ['tenants.tenant_id'], name=op.f('ai_user_preferences_tenant_id_fkey'), ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('tenant_id', 'user_id', 'preference_key', name=op.f('pk_ai_user_prefs'))
    )
    op.create_table('erasure_requests',
    sa.Column('tenant_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('request_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.Column('subject_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('subject_entity_code', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('requester_id', sa.UUID(), autoincrement=False, nullable=True),
    sa.Column('requester_email', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('regulation_basis', sa.TEXT(), server_default=sa.text("'DPDP_ACT_2023'::text"), autoincrement=False, nullable=False),
    sa.Column('received_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.Column('completed_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
    sa.Column('cap_log_id', sa.UUID(), autoincrement=False, nullable=True),
    sa.Column('metadata', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['tenant_id'], ['tenants.tenant_id'], name=op.f('erasure_requests_tenant_id_fkey'), ondelete='RESTRICT'),
    sa.PrimaryKeyConstraint('tenant_id', 'request_id', name=op.f('pk_erasure_requests')),
    sa.UniqueConstraint('request_id', name=op.f('uq_erasure_request_id')),
    comment='LAW 09-1.3: Each erasure request is a first-class workflow entity. Current state derived at runtime from workflow_state_log. fn_execute_cap() must only fire when state reaches IN_PROGRESS.'
    )
    op.create_index(op.f('idx_er_subject'), 'erasure_requests', ['tenant_id', 'subject_id'], unique=False)
    op.create_table('circuit_breaker_log',
    sa.Column('tenant_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('event_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.Column('shard_id', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('previous_status', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('new_status', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('trigger_reason', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('tenant_rps_at_event', sa.NUMERIC(precision=10, scale=2), autoincrement=False, nullable=True),
    sa.Column('shard_capacity_pct', sa.NUMERIC(precision=5, scale=2), autoincrement=False, nullable=True),
    sa.Column('auto_resolved_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
    sa.Column('logged_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.ForeignKeyConstraint(['tenant_id'], ['tenants.tenant_id'], name=op.f('circuit_breaker_log_tenant_id_fkey'), ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('tenant_id', 'event_id', name=op.f('pk_circuit_breaker_log')),
    sa.UniqueConstraint('event_id', name=op.f('uq_cb_event_id'))
    )
    op.create_table('audit_event_log',
    sa.Column('tenant_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('log_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.Column('tenant_sequence_number', sa.BIGINT(), autoincrement=False, nullable=False, comment='Monotonic per-tenant sequence number. Set by trigger ??? never supplied by app code. No gaps; used for hash-chain verification.'),
    sa.Column('actor_id', sa.UUID(), autoincrement=False, nullable=True),
    sa.Column('actor_type', sa.TEXT(), server_default=sa.text("'USER'::text"), autoincrement=False, nullable=False, comment='Source of the event: USER | SERVICE | SYSTEM | SCHEDULER | WEBHOOK.'),
    sa.Column('event_category', sa.TEXT(), autoincrement=False, nullable=False, comment='Domain partition: ACADEMIC | FINANCE | AI | WORKFLOW | POLICY | SECURITY | SYSTEM | INTEGRATION.'),
    sa.Column('event_type', sa.TEXT(), autoincrement=False, nullable=False, comment='Screaming-snake event descriptor: e.g. SUBMISSION_CREATED, POLICY_DENIED, FEE_PAID.'),
    sa.Column('entity_id', sa.UUID(), autoincrement=False, nullable=True),
    sa.Column('record_id', sa.UUID(), autoincrement=False, nullable=True),
    sa.Column('event_data', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=False, comment='Structured JSONB event payload. No raw SQL fragments or plaintext PII.'),
    sa.Column('previous_hash', sa.TEXT(), autoincrement=False, nullable=True, comment="SHA-256 hex of the previous row's current_hash. NULL for genesis row (tenant_sequence_number = 1)."),
    sa.Column('current_hash', sa.TEXT(), autoincrement=False, nullable=False, comment='SHA-256 hex digest chaining this row to the previous one. Recomputing and comparing detects tampering.'),
    sa.Column('ip_address_hash', sa.TEXT(), autoincrement=False, nullable=True, comment='SHA-256 hash of actor IP address. Raw IP is never stored (privacy compliance).'),
    sa.Column('session_id', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('logged_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.ForeignKeyConstraint(['tenant_id'], ['tenants.tenant_id'], name=op.f('audit_event_log_tenant_id_fkey'), ondelete='RESTRICT'),
    sa.PrimaryKeyConstraint('tenant_id', 'log_id', name=op.f('pk_audit_event_log')),
    sa.UniqueConstraint('log_id', name=op.f('uq_audit_log_id')),
    sa.UniqueConstraint('tenant_id', 'tenant_sequence_number', name=op.f('uq_audit_sequence')),
    comment='Layer 9 / LAW 8: Primary cryptographically-chained, INSERT-ONLY audit ledger. Immutability enforced by trigger + role GRANT. Hash chain detects tampering.'
    )
    op.create_index(op.f('idx_ael_tenant_seq'), 'audit_event_log', ['tenant_id', 'tenant_sequence_number'], unique=False)
    op.create_index(op.f('idx_ael_record'), 'audit_event_log', ['tenant_id', 'record_id', sa.literal_column('logged_at DESC')], unique=False, postgresql_where='(record_id IS NOT NULL)')
    op.create_index(op.f('idx_ael_logged_at'), 'audit_event_log', ['tenant_id', sa.literal_column('logged_at DESC')], unique=False)
    op.create_index(op.f('idx_ael_event_type'), 'audit_event_log', ['tenant_id', 'event_category', 'event_type', sa.literal_column('logged_at DESC')], unique=False)
    op.create_index(op.f('idx_ael_actor'), 'audit_event_log', ['tenant_id', 'actor_id', sa.literal_column('logged_at DESC')], unique=False)
    op.create_table('attribute_values',
    sa.Column('tenant_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('attribute_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('record_id', sa.UUID(), autoincrement=False, nullable=False, comment='UUID of the specific entity instance (e.g. a user_id, course_id, etc.).'),
    sa.Column('value_text', sa.TEXT(), autoincrement=False, nullable=True, comment='Stores text, JSON, date strings, and file references.'),
    sa.Column('value_number', sa.NUMERIC(), autoincrement=False, nullable=True, comment='Stores numeric values with full precision.'),
    sa.Column('value_bool', sa.BOOLEAN(), autoincrement=False, nullable=True),
    sa.Column('created_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.Column('updated_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.ForeignKeyConstraint(['tenant_id', 'attribute_id'], ['attribute_master.tenant_id', 'attribute_master.attribute_id'], name=op.f('fk_attribute_values_attr'), ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['tenant_id'], ['tenants.tenant_id'], name=op.f('attribute_values_tenant_id_fkey'), ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('tenant_id', 'attribute_id', 'record_id', name=op.f('pk_attribute_values')),
    comment='EAV value store. Holds dynamic field values for any entity record. LAW 2 enforcement.'
    )
    op.create_index(op.f('idx_attribute_values_record'), 'attribute_values', ['tenant_id', 'record_id'], unique=False)
    op.create_table('entity_record_index',
    sa.Column('tenant_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('index_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.Column('record_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('entity_id', sa.UUID(), autoincrement=False, nullable=False, comment='Denormalised FK to entity_master; enables entity-type-scoped search without a join.'),
    sa.Column('attribute_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('index_value', sa.TEXT(), autoincrement=False, nullable=False, comment='Normalised text representation of the attribute value, lowercased for case-insensitive matching.'),
    sa.Column('index_value_num', sa.NUMERIC(), autoincrement=False, nullable=True, comment='Numeric mirror of the value for range queries (BETWEEN, >, <, etc.).'),
    sa.Column('tsvector_value', postgresql.TSVECTOR(), autoincrement=False, nullable=True, comment='Pre-computed PostgreSQL TSVECTOR for fast full-text search via GIN index.'),
    sa.Column('indexed_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.ForeignKeyConstraint(['tenant_id', 'attribute_id'], ['attribute_master.tenant_id', 'attribute_master.attribute_id'], name=op.f('fk_eri_attribute'), ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['tenant_id', 'record_id'], ['entity_records.tenant_id', 'entity_records.record_id'], name=op.f('fk_eri_record'), ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['tenant_id'], ['tenants.tenant_id'], name=op.f('entity_record_index_tenant_id_fkey'), ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('tenant_id', 'index_id', name=op.f('pk_entity_record_index')),
    sa.UniqueConstraint('index_id', name=op.f('uq_index_id')),
    sa.UniqueConstraint('tenant_id', 'record_id', 'attribute_id', name=op.f('uq_eri_record_attribute')),
    comment='Layer 6: Search-optimised mirror of entity_attribute_values for is_searchable attributes only. NOT authoritative ??? source of truth is entity_attribute_values.'
    )
    op.create_index(op.f('idx_eri_tenant_entity'), 'entity_record_index', ['tenant_id', 'entity_id'], unique=False)
    op.create_index(op.f('idx_eri_fts'), 'entity_record_index', ['tsvector_value'], unique=False, postgresql_using='gin', postgresql_where='(tsvector_value IS NOT NULL)')
    op.create_index(op.f('idx_eri_attribute_value'), 'entity_record_index', ['tenant_id', 'attribute_id', 'index_value'], unique=False)
    op.create_index(op.f('idx_eri_attribute_num'), 'entity_record_index', ['tenant_id', 'attribute_id', 'index_value_num'], unique=False, postgresql_where='(index_value_num IS NOT NULL)')
    op.create_table('form_master',
    sa.Column('tenant_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('form_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.Column('form_code', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('display_name', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('entity_id', sa.UUID(), autoincrement=False, nullable=False, comment='The entity whose attributes this form collects (drives field binding).'),
    sa.Column('workflow_id', sa.UUID(), autoincrement=False, nullable=True, comment='If set, form submission fires the initial_state entry event of this workflow.'),
    sa.Column('description', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('is_active', sa.BOOLEAN(), server_default=sa.text('true'), autoincrement=False, nullable=False),
    sa.Column('version', sa.INTEGER(), server_default=sa.text('1'), autoincrement=False, nullable=False, comment='Monotonically increasing version counter; bump on structural change.'),
    sa.Column('created_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.Column('updated_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.ForeignKeyConstraint(['tenant_id', 'entity_id'], ['entity_master.tenant_id', 'entity_master.entity_id'], name=op.f('fk_form_entity'), ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['tenant_id', 'workflow_id'], ['workflow_master.tenant_id', 'workflow_master.workflow_id'], name=op.f('fk_form_workflow'), ondelete='SET NULL'),
    sa.ForeignKeyConstraint(['tenant_id'], ['tenants.tenant_id'], name=op.f('form_master_tenant_id_fkey'), ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('tenant_id', 'form_id', name=op.f('pk_form_master')),
    sa.UniqueConstraint('form_id', name=op.f('uq_form_id')),
    sa.UniqueConstraint('tenant_id', 'form_code', name=op.f('uq_form_code')),
    comment='LAW 11: Every form in the OS is a data row here. No new table needed per form type.'
    )
    op.create_index(op.f('idx_form_entity'), 'form_master', ['tenant_id', 'entity_id'], unique=False)
    op.create_table('policy_conditions',
    sa.Column('tenant_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('condition_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.Column('policy_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('condition_code', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('condition_group', sa.TEXT(), server_default=sa.text("'default'::text"), autoincrement=False, nullable=False, comment='Named group for scoping AND/OR nesting. Conditions in the same group share combine_operator.'),
    sa.Column('combine_operator', sa.TEXT(), server_default=sa.text("'AND'::text"), autoincrement=False, nullable=False, comment='How this condition combines with siblings in the same group: AND | OR.'),
    sa.Column('subject_type', sa.TEXT(), server_default=sa.text("'ATTRIBUTE'::text"), autoincrement=False, nullable=False, comment='What kind of thing is being tested: ATTRIBUTE | ROLE | TIME | QUOTA | CUSTOM_DSL.'),
    sa.Column('attribute_id', sa.UUID(), autoincrement=False, nullable=True, comment='For subject_type=ATTRIBUTE: the attribute whose runtime value is evaluated.'),
    sa.Column('operator', sa.TEXT(), autoincrement=False, nullable=False, comment='Comparison operator: eq | ne | lt | lte | gt | gte | in | not_in | contains | matches_regex.'),
    sa.Column('rule_definition', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=True),
    sa.Column('comparison_value', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=True, comment='Expected value(s) as typed JSON. E.g. 18 (number), "ACTIVE" (string), [1,2,3] (set).'),
    sa.Column('description', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('dsl_expression', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=True, comment='Full JSON Logic tree used when subject_type=CUSTOM_DSL. Overrides attribute_id + operator.'),
    sa.Column('negate', sa.BOOLEAN(), server_default=sa.text('false'), autoincrement=False, nullable=False, comment='When TRUE the condition is logically negated (NOT predicate).'),
    sa.Column('sort_order', sa.INTEGER(), server_default=sa.text('0'), autoincrement=False, nullable=False),
    sa.Column('created_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.CheckConstraint("combine_operator = ANY (ARRAY['AND'::text, 'OR'::text])", name=op.f('policy_conditions_combine_operator_check')),
    sa.ForeignKeyConstraint(['tenant_id', 'attribute_id'], ['attribute_master.tenant_id', 'attribute_master.attribute_id'], name=op.f('fk_pc_attribute'), ondelete='RESTRICT'),
    sa.ForeignKeyConstraint(['tenant_id', 'policy_id'], ['policy_master.tenant_id', 'policy_master.policy_id'], name=op.f('fk_pc_policy'), ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['tenant_id'], ['tenants.tenant_id'], name=op.f('policy_conditions_tenant_id_fkey'), ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('tenant_id', 'condition_id', name=op.f('pk_policy_conditions')),
    sa.UniqueConstraint('condition_id', name=op.f('uq_policy_condition_id')),
    sa.UniqueConstraint('tenant_id', 'policy_id', 'condition_code', name=op.f('uq_policy_condition')),
    comment='Layer 5: Structured DSL predicates for a policy. No free text or raw SQL ever (LAW 9). Evaluated by the policy engine BEFORE workflow transitions (LAW 4).'
    )
    op.create_index(op.f('idx_pcond_policy'), 'policy_conditions', ['tenant_id', 'policy_id', 'sort_order'], unique=False)
    op.create_index(op.f('idx_pcond_attribute'), 'policy_conditions', ['tenant_id', 'attribute_id'], unique=False, postgresql_where='(attribute_id IS NOT NULL)')
    op.create_table('cold_archive_manifest',
    sa.Column('tenant_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('manifest_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.Column('archive_type', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('date_range_start', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=False),
    sa.Column('date_range_end', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=False),
    sa.Column('record_count', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('seq_range_start', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('seq_range_end', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('batch_hash', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('manifest_hash', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('cold_storage_uri', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('worm_object_lock_expiry', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=False),
    sa.Column('worm_region', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('archived_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.Column('archived_by', sa.UUID(), autoincrement=False, nullable=False),
    sa.CheckConstraint("archive_type = ANY (ARRAY['AUDIT_EVENTS'::text, 'EAV_VALUES'::text, 'FINANCE_LEDGER'::text, 'WORKFLOW_LOG'::text, 'MIXED'::text])", name=op.f('cold_archive_manifest_archive_type_check')),
    sa.CheckConstraint('date_range_end > date_range_start', name=op.f('chk_bam_date_range')),
    sa.ForeignKeyConstraint(['tenant_id'], ['tenants.tenant_id'], name=op.f('cold_archive_manifest_tenant_id_fkey'), ondelete='RESTRICT'),
    sa.PrimaryKeyConstraint('tenant_id', 'manifest_id', name=op.f('pk_cold_archive_manifest')),
    sa.UniqueConstraint('manifest_id', name=op.f('uq_manifest_id')),
    comment='LAW 09-5.2: Batch Archive Manifest (BAM). One INSERT-ONLY row per cold storage batch. manifest_hash and batch_hash seal the archive cryptographically. Must be stored both in cold WORM storage AND appended to the hot audit chain (LAW 09-5.5).'
    )
    op.create_index(op.f('idx_cam_type'), 'cold_archive_manifest', ['tenant_id', 'archive_type', sa.literal_column('archived_at DESC')], unique=False)
    op.create_index(op.f('idx_cam_tenant_date'), 'cold_archive_manifest', ['tenant_id', 'date_range_start', 'date_range_end'], unique=False)
    op.create_table('ai_model_registry',
    sa.Column('tenant_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('model_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.Column('model_code', sa.TEXT(), autoincrement=False, nullable=False, comment='Tenant-scoped machine identifier e.g. "gemini-3-pro". Used by application code to resolve the model at runtime.'),
    sa.Column('display_name', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('provider', sa.TEXT(), autoincrement=False, nullable=False, comment='Commercial or hosting label: GOOGLE | OPENAI | ANTHROPIC | MISTRAL | SELF_HOSTED | CUSTOM.'),
    sa.Column('model_type', sa.TEXT(), autoincrement=False, nullable=False, comment='Task category: LLM | EMBEDDING | VISION | SPEECH_TO_TEXT | TEXT_TO_SPEECH | CLASSIFIER | RERANKER | CUSTOM.'),
    sa.Column('endpoint_url', sa.TEXT(), autoincrement=False, nullable=True, comment='Base inference URL for self-hosted models. NULL for provider-SDK models resolved via API key.'),
    sa.Column('api_key_secret_ref', sa.TEXT(), autoincrement=False, nullable=True, comment='Secret Manager reference path. The actual credential is NEVER stored in this column.'),
    sa.Column('capabilities', postgresql.ARRAY(sa.TEXT()), server_default=sa.text("'{}'::text[]"), autoincrement=False, nullable=False, comment='Array of capability tags: chat, function_calling, json_mode, vision, long_context, streaming.'),
    sa.Column('context_window', sa.INTEGER(), autoincrement=False, nullable=True, comment='Maximum token context length. NULL for non-token-based models.'),
    sa.Column('max_output_tokens', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('input_cost_per_1k', sa.NUMERIC(precision=12, scale=6), autoincrement=False, nullable=True),
    sa.Column('output_cost_per_1k', sa.NUMERIC(precision=12, scale=6), autoincrement=False, nullable=True),
    sa.Column('is_default', sa.BOOLEAN(), server_default=sa.text('false'), autoincrement=False, nullable=False, comment='TRUE marks this as the tenant default for its model_type. Enforce at most one TRUE per (tenant_id, model_type) at application layer.'),
    sa.Column('is_active', sa.BOOLEAN(), server_default=sa.text('true'), autoincrement=False, nullable=False),
    sa.Column('model_config', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=True, comment='Provider-specific JSONB config (temperature, top_p, safety thresholds). Evolves without migrations (LAW 11).'),
    sa.Column('created_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.Column('updated_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.CheckConstraint("model_type = ANY (ARRAY['LLM'::text, 'EMBEDDING'::text, 'VISION'::text, 'SPEECH_TO_TEXT'::text, 'TEXT_TO_SPEECH'::text, 'CLASSIFIER'::text, 'RERANKER'::text, 'CUSTOM'::text])", name=op.f('ai_model_registry_model_type_check')),
    sa.ForeignKeyConstraint(['tenant_id'], ['tenants.tenant_id'], name=op.f('ai_model_registry_tenant_id_fkey'), ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('tenant_id', 'model_id', name=op.f('pk_ai_model_registry')),
    sa.UniqueConstraint('model_id', name=op.f('uq_ai_model_id')),
    sa.UniqueConstraint('tenant_id', 'model_code', name=op.f('uq_ai_model_code')),
    comment='Layer 7: Single source of truth for every AI/ML model the OS can invoke. Application code resolves endpoints here ??? never hard-codes URLs or model names (LAW 12).'
    )
    op.create_index(op.f('idx_ai_model_type'), 'ai_model_registry', ['tenant_id', 'model_type', 'is_active'], unique=False)
    op.create_index(op.f('idx_ai_model_default'), 'ai_model_registry', ['tenant_id', 'model_type', 'is_default'], unique=False, postgresql_where='(is_default = true)')
    op.create_table('tenant_activity_metrics',
    sa.Column('tenant_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('metric_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.Column('metric_category', sa.TEXT(), autoincrement=False, nullable=False, comment='What is counted: API_CALLS | AI_TOKENS | STORAGE_BYTES | ACTIVE_USERS | WORKFLOW_TRANSITIONS | FORM_SUBMISSIONS | AUDIT_EVENTS | CUSTOM.'),
    sa.Column('window_start', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=False),
    sa.Column('window_end', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=False),
    sa.Column('window_granularity', sa.TEXT(), autoincrement=False, nullable=False, comment='Aggregation bucket: HOURLY | DAILY | WEEKLY | MONTHLY.'),
    sa.Column('scope_ref_id', sa.UUID(), autoincrement=False, nullable=True, comment='Optional entity_records.record_id to narrow metrics to a specific school or class.'),
    sa.Column('count_value', sa.BIGINT(), server_default=sa.text('0'), autoincrement=False, nullable=False, comment='Discrete event count within the window (e.g. number of API calls).'),
    sa.Column('sum_value', sa.NUMERIC(precision=20, scale=6), autoincrement=False, nullable=True, comment='Continuous total within the window (e.g. total tokens consumed, total bytes written).'),
    sa.Column('peak_value', sa.NUMERIC(precision=20, scale=6), autoincrement=False, nullable=True, comment='Peak instantaneous value observed within the window (e.g. peak concurrent users).'),
    sa.Column('metadata', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=True),
    sa.Column('aggregated_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.CheckConstraint("metric_category = ANY (ARRAY['API_CALLS'::text, 'AI_TOKENS'::text, 'STORAGE_BYTES'::text, 'ACTIVE_USERS'::text, 'WORKFLOW_TRANSITIONS'::text, 'FORM_SUBMISSIONS'::text, 'AUDIT_EVENTS'::text, 'CUSTOM'::text])", name=op.f('tenant_activity_metrics_metric_category_check')),
    sa.CheckConstraint("window_granularity = ANY (ARRAY['HOURLY'::text, 'DAILY'::text, 'WEEKLY'::text, 'MONTHLY'::text])", name=op.f('tenant_activity_metrics_window_granularity_check')),
    sa.CheckConstraint('window_end > window_start', name=op.f('chk_window_order')),
    sa.ForeignKeyConstraint(['tenant_id'], ['tenants.tenant_id'], name=op.f('tenant_activity_metrics_tenant_id_fkey'), ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('tenant_id', 'metric_id', name=op.f('pk_tenant_activity_metrics')),
    sa.UniqueConstraint('metric_id', name=op.f('uq_activity_metric_id')),
    sa.UniqueConstraint('tenant_id', 'metric_category', 'window_start', 'window_granularity', 'scope_ref_id', name=op.f('uq_metric_window')),
    comment='Layer 9: Pre-aggregated operational metrics per tenant per time window. Written by background aggregation job ??? INSERT-ONLY. LAW 9: no raw SQL queries inline.'
    )
    op.create_index(op.f('idx_tam_scope'), 'tenant_activity_metrics', ['tenant_id', 'scope_ref_id', 'metric_category'], unique=False, postgresql_where='(scope_ref_id IS NOT NULL)')
    op.create_index(op.f('idx_tam_category_window'), 'tenant_activity_metrics', ['tenant_id', 'metric_category', sa.literal_column('window_start DESC')], unique=False)
    op.create_table('entity_master',
    sa.Column('tenant_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('entity_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.Column('entity_type', sa.TEXT(), autoincrement=False, nullable=False, comment='Category/category of entity: USER | COURSE | BATCH | QUESTION | FORM | etc.'),
    sa.Column('entity_code', sa.TEXT(), autoincrement=False, nullable=False, comment='Tenant-scoped short identifier, used in configuration/policy references.'),
    sa.Column('display_name', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('description', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('is_system', sa.BOOLEAN(), server_default=sa.text('false'), autoincrement=False, nullable=False, comment='TRUE for OS-built-in entities that tenants cannot delete.'),
    sa.Column('is_active', sa.BOOLEAN(), server_default=sa.text('true'), autoincrement=False, nullable=False),
    sa.Column('created_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.ForeignKeyConstraint(['tenant_id'], ['tenants.tenant_id'], name=op.f('entity_master_tenant_id_fkey'), ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('tenant_id', 'entity_id', name=op.f('pk_entity_master')),
    sa.UniqueConstraint('entity_id', name=op.f('uq_entity_master_id')),
    sa.UniqueConstraint('tenant_id', 'entity_code', name=op.f('uq_entity_master_code')),
    comment='LAW 1: Central registry of every first-class entity type in the OS. No entity exists outside this table.'
    )
    op.create_index(op.f('idx_entity_master_type'), 'entity_master', ['tenant_id', 'entity_type'], unique=False)
    op.create_table('tenants',
    sa.Column('tenant_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False, comment='Globally unique tenant identifier. Injected into every session via RLS.'),
    sa.Column('name', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('slug', sa.TEXT(), autoincrement=False, nullable=False, comment='URL-safe unique shortcode for the tenant (e.g. "greenwood-iit").'),
    sa.Column('plan', sa.TEXT(), server_default=sa.text("'free'::text"), autoincrement=False, nullable=False, comment='Subscription tier controlling feature flags (free | starter | pro | enterprise).'),
    sa.Column('is_active', sa.BOOLEAN(), server_default=sa.text('true'), autoincrement=False, nullable=False),
    sa.Column('created_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.Column('updated_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.Column('data_residency_region', sa.TEXT(), autoincrement=False, nullable=True, comment='LAW 09-6.1: Immutable data residency region code. Set once at provisioning. Format: COUNTRY_CODE-CITY_CODE (e.g. IN-MUM, EU-IRL, US-VA, SG-SIN). NULL means no residency constraint ??? only for pre-LAW tenants. Immutability enforced by trg_tenants_residency_immutable trigger.'),
    sa.CheckConstraint("data_residency_region ~ '^[A-Z]{2}-[A-Z]{2,6}$'::text", name=op.f('tenants_data_residency_region_check')),
    sa.PrimaryKeyConstraint('tenant_id', name=op.f('pk_tenants')),
    sa.UniqueConstraint('slug', name=op.f('tenants_slug_key')),
    comment='Root anchor for all tenants (organisations/schools). The kernel; never deleted.'
    )
    op.create_table('policy_master',
    sa.Column('tenant_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('policy_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.Column('policy_code', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('display_name', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('entity_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('rule_engine', sa.TEXT(), server_default=sa.text("'json_logic'::text"), autoincrement=False, nullable=False, comment='Engine used to evaluate rule_definition (json_logic | cel | rego).'),
    sa.Column('rule_definition', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=False, comment='Machine-readable predicate evaluated at runtime against the request context.'),
    sa.Column('evaluation_order', sa.INTEGER(), server_default=sa.text('100'), autoincrement=False, nullable=False, comment='Evaluation order; lower number = higher priority. Ties broken by created_at.'),
    sa.Column('is_active', sa.BOOLEAN(), server_default=sa.text('true'), autoincrement=False, nullable=False),
    sa.Column('created_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.ForeignKeyConstraint(['tenant_id', 'entity_id'], ['entity_master.tenant_id', 'entity_master.entity_id'], name=op.f('fk_policy_entity'), ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['tenant_id'], ['tenants.tenant_id'], name=op.f('policy_master_tenant_id_fkey'), ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('tenant_id', 'policy_id', name=op.f('pk_policy_master')),
    sa.UniqueConstraint('policy_id', name=op.f('uq_policy_id')),
    sa.UniqueConstraint('tenant_id', 'policy_code', name=op.f('uq_policy_code')),
    comment='LAW 4+5: Declarative policy registry. Evaluated BEFORE workflow transitions. Policies decide IF.'
    )
    op.create_index(op.f('idx_policy_entity'), 'policy_master', ['tenant_id', 'entity_id', 'evaluation_order'], unique=False)
    op.create_table('entity_attribute_value_history',
    sa.Column('tenant_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('history_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.Column('value_id', sa.UUID(), autoincrement=False, nullable=False, comment='References the entity_attribute_values row whose value was superseded.'),
    sa.Column('record_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('attribute_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('old_value_text', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('old_value_number', sa.NUMERIC(), autoincrement=False, nullable=True),
    sa.Column('old_value_bool', sa.BOOLEAN(), autoincrement=False, nullable=True),
    sa.Column('old_value_jsonb', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=True),
    sa.Column('changed_by', sa.UUID(), autoincrement=False, nullable=True),
    sa.Column('change_reason', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('superseded_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False, comment='Timestamp when this value was replaced. Enables point-in-time reconstruction.'),
    sa.ForeignKeyConstraint(['tenant_id', 'attribute_id'], ['attribute_master.tenant_id', 'attribute_master.attribute_id'], name=op.f('fk_eavh_attribute'), ondelete='RESTRICT'),
    sa.ForeignKeyConstraint(['tenant_id'], ['tenants.tenant_id'], name=op.f('entity_attribute_value_history_tenant_id_fkey'), ondelete='RESTRICT'),
    sa.PrimaryKeyConstraint('tenant_id', 'history_id', name=op.f('pk_entity_attribute_value_history')),
    sa.UniqueConstraint('history_id', name=op.f('uq_eav_history_id')),
    comment='Layer 6 / LAW 8: INSERT-ONLY value history. Every overwrite of entity_attribute_values creates a row here. Never updated or deleted.'
    )
    op.create_index(op.f('idx_eavh_value'), 'entity_attribute_value_history', ['tenant_id', 'value_id', sa.literal_column('superseded_at DESC')], unique=False)
    op.create_index(op.f('idx_eavh_record'), 'entity_attribute_value_history', ['tenant_id', 'record_id', sa.literal_column('superseded_at DESC')], unique=False)
    op.create_table('entity_records',
    sa.Column('tenant_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('record_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.Column('entity_id', sa.UUID(), autoincrement=False, nullable=False, comment='FK to entity_master defining the type/schema of this instance.'),
    sa.Column('current_state_id', sa.UUID(), autoincrement=False, nullable=True),
    sa.Column('display_name', sa.TEXT(), autoincrement=False, nullable=True, comment='Optional denormalised label for list views. Source of truth for the actual value remains entity_attribute_values.'),
    sa.Column('is_active', sa.BOOLEAN(), server_default=sa.text('true'), autoincrement=False, nullable=False),
    sa.Column('created_by', sa.UUID(), autoincrement=False, nullable=True),
    sa.Column('created_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.Column('updated_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.Column('deleted_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True, comment='Soft-delete timestamp. Application layer filters WHERE deleted_at IS NULL for live records.'),
    sa.ForeignKeyConstraint(['tenant_id', 'current_state_id'], ['workflow_states.tenant_id', 'workflow_states.state_id'], name=op.f('fk_er_current_state'), ondelete='SET NULL'),
    sa.ForeignKeyConstraint(['tenant_id', 'entity_id'], ['entity_master.tenant_id', 'entity_master.entity_id'], name=op.f('fk_er_entity'), ondelete='RESTRICT'),
    sa.ForeignKeyConstraint(['tenant_id'], ['tenants.tenant_id'], name=op.f('entity_records_tenant_id_fkey'), ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('tenant_id', 'record_id', name=op.f('pk_entity_records')),
    sa.UniqueConstraint('record_id', name=op.f('uq_record_id')),
    comment='Layer 6: One row per entity instance (student, course, batch, etc.). Envelope only ??? field data is in entity_attribute_values. LAW 2: no custom columns.'
    )
    op.create_index(op.f('idx_er_entity'), 'entity_records', ['tenant_id', 'entity_id'], unique=False)
    op.create_index(op.f('idx_er_created'), 'entity_records', ['tenant_id', 'entity_id', sa.literal_column('created_at DESC')], unique=False)
    op.create_index(op.f('idx_er_active'), 'entity_records', ['tenant_id', 'entity_id', 'is_active'], unique=False, postgresql_where='(deleted_at IS NULL)')
    op.create_table('report_measures',
    sa.Column('tenant_id', sa.UUID(), autoincrement=False, nullable=True, comment='NULL for measures belonging to SYSTEM template reports.'),
    sa.Column('measure_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.Column('report_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('attribute_id', sa.UUID(), autoincrement=False, nullable=True, comment='FK to attribute_master. Required for ATTRIBUTE source; NULL for RECORD_COUNT or EXPRESSION.'),
    sa.Column('measure_source', sa.TEXT(), server_default=sa.text("'ATTRIBUTE'::text"), autoincrement=False, nullable=False, comment='What to aggregate: ATTRIBUTE | RECORD_COUNT (COUNT(*)) | EXPRESSION (JSON Logic DSL).'),
    sa.Column('aggregate_fn', sa.TEXT(), autoincrement=False, nullable=False, comment='Aggregation function: COUNT | COUNT_DISTINCT | SUM | AVG | MIN | MAX | MEDIAN | PERCENTILE_90.'),
    sa.Column('expression_dsl', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=True),
    sa.Column('display_label', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('format_type', sa.TEXT(), server_default=sa.text("'NUMBER'::text"), autoincrement=False, nullable=False, comment='Rendering hint for UI and export: NUMBER | CURRENCY | PERCENTAGE | DURATION_HRS | CUSTOM.'),
    sa.Column('decimal_places', sa.INTEGER(), server_default=sa.text('0'), autoincrement=False, nullable=False),
    sa.Column('is_primary', sa.BOOLEAN(), server_default=sa.text('false'), autoincrement=False, nullable=False, comment='TRUE = headline measure for dashboard summary cards.'),
    sa.Column('sort_order', sa.INTEGER(), server_default=sa.text('0'), autoincrement=False, nullable=False),
    sa.Column('is_active', sa.BOOLEAN(), server_default=sa.text('true'), autoincrement=False, nullable=False),
    sa.CheckConstraint("aggregate_fn = ANY (ARRAY['COUNT'::text, 'COUNT_DISTINCT'::text, 'SUM'::text, 'AVG'::text, 'MIN'::text, 'MAX'::text, 'MEDIAN'::text, 'PERCENTILE_90'::text])", name=op.f('report_measures_aggregate_fn_check')),
    sa.CheckConstraint("format_type = ANY (ARRAY['NUMBER'::text, 'CURRENCY'::text, 'PERCENTAGE'::text, 'DURATION_HRS'::text, 'CUSTOM'::text])", name=op.f('report_measures_format_type_check')),
    sa.CheckConstraint("measure_source = ANY (ARRAY['ATTRIBUTE'::text, 'RECORD_COUNT'::text, 'EXPRESSION'::text])", name=op.f('report_measures_measure_source_check')),
    sa.ForeignKeyConstraint(['attribute_id'], ['attribute_master.attribute_id'], name=op.f('fk_rmeas_attribute'), ondelete='RESTRICT'),
    sa.ForeignKeyConstraint(['report_id'], ['report_master.report_id'], name=op.f('fk_rmeas_report'), ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('measure_id', name=op.f('pk_report_measures')),
    comment='Layer 10 / LAW 9: Aggregated metric column definitions for a report. Engine builds SELECT aggregates from these rows ??? no raw SQL stored. LAW 10: no grade/rank columns.'
    )
    op.create_index(op.f('idx_rmeas_report'), 'report_measures', ['report_id', 'sort_order'], unique=False)
    op.create_table('workflow_state_log',
    sa.Column('seq_id', sa.BIGINT(), autoincrement=True, nullable=False),
    sa.Column('tenant_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('log_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.Column('workflow_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('record_id', sa.UUID(), autoincrement=False, nullable=False, comment='UUID of the entity instance whose state changed.'),
    sa.Column('from_state', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('to_state', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('trigger_event', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('actor_id', sa.UUID(), autoincrement=False, nullable=True, comment='User or automated agent that fired the transition.'),
    sa.Column('transition_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.Column('metadata', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=True, comment='Contextual data at transition time (e.g. policy result, payload).'),
    sa.ForeignKeyConstraint(['tenant_id', 'workflow_id'], ['workflow_master.tenant_id', 'workflow_master.workflow_id'], name=op.f('fk_wsl_workflow'), ondelete='RESTRICT'),
    sa.ForeignKeyConstraint(['tenant_id'], ['tenants.tenant_id'], name=op.f('workflow_state_log_tenant_id_fkey'), ondelete='RESTRICT'),
    sa.PrimaryKeyConstraint('tenant_id', 'log_id', name=op.f('pk_workflow_state_log')),
    sa.UniqueConstraint('log_id', name=op.f('uq_workflow_log_id')),
    comment='LAW 8: INSERT-ONLY history of all state transitions. Source of truth for current state (latest row per record_id).'
    )
    op.create_index(op.f('idx_wsl_record'), 'workflow_state_log', ['tenant_id', 'record_id', sa.literal_column('transition_at DESC')], unique=False)
    op.create_table('audit_state_snapshot',
    sa.Column('tenant_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('snapshot_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.Column('audit_log_id', sa.UUID(), autoincrement=False, nullable=False, comment='FK to the audit_event_log entry that triggered this snapshot.'),
    sa.Column('record_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('entity_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('snapshot_type', sa.TEXT(), autoincrement=False, nullable=False, comment='Timing of capture: BEFORE (pre-transition) | AFTER (post-transition) | POINT_IN_TIME (on-demand).'),
    sa.Column('state_data', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=False, comment='JSONB map of {attribute_code: value} for the record at capture time. Immutable after insert.'),
    sa.Column('workflow_state_code', sa.TEXT(), autoincrement=False, nullable=True, comment='workflow_states.state_code at capture time ??? denormalised for forensic readability.'),
    sa.Column('captured_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.CheckConstraint("snapshot_type = ANY (ARRAY['BEFORE'::text, 'AFTER'::text, 'POINT_IN_TIME'::text])", name=op.f('audit_state_snapshot_snapshot_type_check')),
    sa.ForeignKeyConstraint(['tenant_id', 'audit_log_id'], ['audit_event_log.tenant_id', 'audit_event_log.log_id'], name=op.f('fk_ass_audit_log'), ondelete='RESTRICT'),
    sa.ForeignKeyConstraint(['tenant_id'], ['tenants.tenant_id'], name=op.f('audit_state_snapshot_tenant_id_fkey'), ondelete='RESTRICT'),
    sa.PrimaryKeyConstraint('tenant_id', 'snapshot_id', name=op.f('pk_audit_state_snapshot')),
    sa.UniqueConstraint('snapshot_id', name=op.f('uq_snapshot_id')),
    comment='Layer 9 / LAW 8: Full-record state captures linked to audit events. JSONB snapshot survives future schema changes. INSERT-ONLY.'
    )
    op.create_index(op.f('idx_ass_record'), 'audit_state_snapshot', ['tenant_id', 'record_id', sa.literal_column('captured_at DESC')], unique=False)
    op.create_index(op.f('idx_ass_audit_log'), 'audit_state_snapshot', ['tenant_id', 'audit_log_id'], unique=False)
    op.create_table('workflow_states',
    sa.Column('tenant_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('state_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.Column('workflow_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('state_code', sa.TEXT(), autoincrement=False, nullable=False, comment='SCREAMING_SNAKE_CASE machine identifier; must match workflow_master.initial_state for entry states.'),
    sa.Column('display_label', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('description', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('state_type', sa.TEXT(), autoincrement=False, nullable=False, comment='Lifecycle role: initial | intermediate | terminal | error.'),
    sa.Column('is_blocking', sa.BOOLEAN(), server_default=sa.text('false'), autoincrement=False, nullable=False, comment='TRUE means the entity is waiting on an external actor and should be surfaced in task queues.'),
    sa.Column('sla_hours', sa.NUMERIC(), autoincrement=False, nullable=True, comment='Soft SLA target. An escalation event fires when an entity remains in this state beyond this window.'),
    sa.Column('ui_color', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('sort_order', sa.INTEGER(), server_default=sa.text('0'), autoincrement=False, nullable=False),
    sa.Column('created_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.CheckConstraint("state_type = ANY (ARRAY['initial'::text, 'intermediate'::text, 'terminal'::text, 'error'::text])", name=op.f('workflow_states_state_type_check')),
    sa.ForeignKeyConstraint(['tenant_id', 'workflow_id'], ['workflow_master.tenant_id', 'workflow_master.workflow_id'], name=op.f('fk_ws_workflow'), ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['tenant_id'], ['tenants.tenant_id'], name=op.f('workflow_states_tenant_id_fkey'), ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('tenant_id', 'state_id', name=op.f('pk_workflow_states')),
    sa.UniqueConstraint('state_id', name=op.f('uq_workflow_state_id')),
    sa.UniqueConstraint('tenant_id', 'workflow_id', 'state_code', name=op.f('uq_workflow_state_code')),
    comment='Layer 4: Enumerates every valid state for a workflow. Gives workflow_master (Layer 2) a concrete, typed state registry.'
    )
    op.create_table('ai_capability_master',
    sa.Column('tenant_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('capability_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.Column('capability_code', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('display_name', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('decision_scope', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('is_active', sa.BOOLEAN(), server_default=sa.text('true'), autoincrement=False, nullable=False),
    sa.Column('created_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.CheckConstraint("decision_scope = ANY (ARRAY['ASSISTIVE'::text, 'ADVISORY'::text, 'EVALUATIVE'::text])", name=op.f('ai_capability_master_decision_scope_check')),
    sa.ForeignKeyConstraint(['tenant_id'], ['tenants.tenant_id'], name=op.f('ai_capability_master_tenant_id_fkey'), ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('tenant_id', 'capability_id', name=op.f('pk_ai_capability')),
    sa.UniqueConstraint('tenant_id', 'capability_code', name=op.f('uq_ai_capability_code'))
    )
    op.create_table('workflow_instance_state',
    sa.Column('tenant_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('instance_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.Column('workflow_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('record_id', sa.UUID(), autoincrement=False, nullable=False, comment='UUID of the entity instance whose state is tracked (maps to entity_records.record_id in Layer 6).'),
    sa.Column('current_state_id', sa.UUID(), autoincrement=False, nullable=False, comment='FK to workflow_states; updated on every transition. Authoritative source remains workflow_state_log.'),
    sa.Column('entered_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.Column('sla_deadline', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True, comment='Pre-computed deadline: entered_at + state.sla_hours. Used by scheduler to fire auto-transitions.'),
    sa.Column('assigned_to', sa.UUID(), autoincrement=False, nullable=True),
    sa.Column('metadata', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['tenant_id', 'current_state_id'], ['workflow_states.tenant_id', 'workflow_states.state_id'], name=op.f('fk_wis_state'), ondelete='RESTRICT'),
    sa.ForeignKeyConstraint(['tenant_id', 'workflow_id'], ['workflow_master.tenant_id', 'workflow_master.workflow_id'], name=op.f('fk_wis_workflow'), ondelete='RESTRICT'),
    sa.ForeignKeyConstraint(['tenant_id'], ['tenants.tenant_id'], name=op.f('workflow_instance_state_tenant_id_fkey'), ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('tenant_id', 'instance_id', name=op.f('pk_workflow_instance_state')),
    sa.UniqueConstraint('instance_id', name=op.f('uq_workflow_instance_id')),
    sa.UniqueConstraint('tenant_id', 'workflow_id', 'record_id', name=op.f('uq_wis_record')),
    comment='Layer 4: Fast-read current-state table for each entity instance in a workflow. Denormalised from workflow_state_log (Layer 2).'
    )
    op.create_index(op.f('idx_wis_workflow_state'), 'workflow_instance_state', ['tenant_id', 'workflow_id', 'current_state_id'], unique=False)
    op.create_index(op.f('idx_wis_sla'), 'workflow_instance_state', ['tenant_id', 'sla_deadline'], unique=False, postgresql_where='(sla_deadline IS NOT NULL)')
    op.create_index(op.f('idx_wis_record'), 'workflow_instance_state', ['tenant_id', 'record_id'], unique=False)
    op.create_table('form_submissions',
    sa.Column('tenant_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('submission_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.Column('form_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('submitted_by', sa.UUID(), autoincrement=False, nullable=False, comment='User UUID; kept here for fast query. Full auth resolved by app layer.'),
    sa.Column('submitted_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.Column('metadata', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=True, comment='Non-answer context: browser info, IP hash, attempt number, etc.'),
    sa.ForeignKeyConstraint(['tenant_id', 'form_id'], ['form_master.tenant_id', 'form_master.form_id'], name=op.f('fk_fsub_form'), ondelete='RESTRICT'),
    sa.ForeignKeyConstraint(['tenant_id'], ['tenants.tenant_id'], name=op.f('form_submissions_tenant_id_fkey'), ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('tenant_id', 'submission_id', name=op.f('pk_form_submissions')),
    sa.UniqueConstraint('submission_id', name=op.f('uq_submission_id')),
    comment='Submission envelope. Actual field answers are in attribute_values (record_id=submission_id). current_state was removed (LAW 8) ??? use v_submission_current_state.'
    )
    op.create_index(op.f('idx_form_submissions_user'), 'form_submissions', ['tenant_id', 'submitted_by'], unique=False)
    op.create_index(op.f('idx_form_submissions_form'), 'form_submissions', ['tenant_id', 'form_id', sa.literal_column('submitted_at DESC')], unique=False)
    op.create_table('api_quota_ledger',
    sa.Column('tenant_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('ledger_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.Column('window_start', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=False),
    sa.Column('window_end', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=False),
    sa.Column('endpoint_tier', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('request_count', sa.INTEGER(), server_default=sa.text('0'), autoincrement=False, nullable=False),
    sa.Column('throttled_count', sa.INTEGER(), server_default=sa.text('0'), autoincrement=False, nullable=False),
    sa.Column('peak_rps', sa.NUMERIC(precision=8, scale=2), autoincrement=False, nullable=True),
    sa.Column('recorded_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.CheckConstraint("endpoint_tier = ANY (ARRAY['TIER-1'::text, 'TIER-2'::text])", name=op.f('api_quota_ledger_endpoint_tier_check')),
    sa.CheckConstraint('window_end > window_start', name=op.f('chk_quota_window')),
    sa.ForeignKeyConstraint(['tenant_id'], ['tenants.tenant_id'], name=op.f('api_quota_ledger_tenant_id_fkey'), ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('tenant_id', 'ledger_id', name=op.f('pk_api_quota_ledger')),
    sa.UniqueConstraint('tenant_id', 'window_start', 'endpoint_tier', name=op.f('uq_quota_window')),
    comment='API quota tracking. TIER-1 = read-only endpoints (high-volume allowed). TIER-2 = write/mutating endpoints (100 writes/min per tenant by default per LAW 09-4.4).'
    )
    op.create_index(op.f('idx_aql_tenant_window'), 'api_quota_ledger', ['tenant_id', sa.literal_column('window_start DESC'), 'endpoint_tier'], unique=False)
    op.create_table('report_master',
    sa.Column('report_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.Column('tenant_id', sa.UUID(), autoincrement=False, nullable=True, comment='NULL = SYSTEM template (accessible to all tenants). UUID = tenant-specific report. LAW 6 exception documented and intentional.'),
    sa.Column('base_report_id', sa.UUID(), autoincrement=False, nullable=True, comment='For tenant overrides of system templates: FK to the original system report_id. NULL for first-party reports.'),
    sa.Column('report_code', sa.TEXT(), autoincrement=False, nullable=False, comment='Dot-namespaced machine identifier unique within (tenant_id, report_code). E.g. "academic.attendance.monthly_summary".'),
    sa.Column('display_name', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('description', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('report_category', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('primary_entity_id', sa.UUID(), autoincrement=False, nullable=False, comment='Root entity for this report. Engine traverses entity_master and attribute_master to resolve columns ??? no hard-coded table names.'),
    sa.Column('report_query_type', sa.TEXT(), server_default=sa.text("'AGGREGATE'::text"), autoincrement=False, nullable=False, comment='Engine path: AGGREGATE | DETAIL | PIVOT | FUNNEL | TIMESERIES.'),
    sa.Column('default_date_range', sa.TEXT(), server_default=sa.text("'CURRENT_MONTH'::text"), autoincrement=False, nullable=False),
    sa.Column('max_rows', sa.INTEGER(), server_default=sa.text('10000'), autoincrement=False, nullable=False, comment='Safety LIMIT applied by the engine to every execution. Prevents runaway queries.'),
    sa.Column('is_exportable', sa.BOOLEAN(), server_default=sa.text('true'), autoincrement=False, nullable=False, comment='When FALSE the engine never produces a downloadable file regardless of user request or role.'),
    sa.Column('export_formats', postgresql.ARRAY(sa.TEXT()), server_default=sa.text("'{CSV,XLSX}'::text[]"), autoincrement=False, nullable=False, comment='Allowed export formats: CSV | XLSX | PDF | JSON. Engine validates against this list before generating.'),
    sa.Column('is_scheduled', sa.BOOLEAN(), server_default=sa.text('false'), autoincrement=False, nullable=False),
    sa.Column('schedule_cron', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('is_active', sa.BOOLEAN(), server_default=sa.text('true'), autoincrement=False, nullable=False),
    sa.Column('sort_order', sa.INTEGER(), server_default=sa.text('0'), autoincrement=False, nullable=False),
    sa.Column('created_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.Column('updated_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.Column('created_by', sa.UUID(), autoincrement=False, nullable=True),
    sa.CheckConstraint("default_date_range = ANY (ARRAY['TODAY'::text, 'CURRENT_WEEK'::text, 'CURRENT_MONTH'::text, 'CURRENT_TERM'::text, 'CURRENT_YEAR'::text, 'ALL_TIME'::text, 'CUSTOM'::text])", name=op.f('report_master_default_date_range_check')),
    sa.CheckConstraint("report_category = ANY (ARRAY['ACADEMIC'::text, 'FINANCE'::text, 'FINANCIAL'::text, 'AI'::text, 'OPERATIONS'::text, 'COMPLIANCE'::text, 'CUSTOM'::text])", name=op.f('report_master_report_category_check')),
    sa.CheckConstraint("report_query_type = ANY (ARRAY['AGGREGATE'::text, 'DETAIL'::text, 'PIVOT'::text, 'FUNNEL'::text, 'TIMESERIES'::text])", name=op.f('report_master_report_query_type_check')),
    sa.ForeignKeyConstraint(['base_report_id'], ['report_master.report_id'], name=op.f('fk_rm_base_report'), ondelete='SET NULL'),
    sa.ForeignKeyConstraint(['primary_entity_id'], ['entity_master.entity_id'], name=op.f('fk_rm_entity'), ondelete='RESTRICT'),
    sa.ForeignKeyConstraint(['tenant_id'], ['tenants.tenant_id'], name=op.f('fk_rm_tenant'), ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('report_id', name=op.f('pk_report_master')),
    sa.UniqueConstraint('tenant_id', 'report_code', name=op.f('uq_report_code_tenant')),
    comment='Layer 10 / LAW 9: Declarative report envelope. No raw SQL stored anywhere. NULL tenant_id = SYSTEM template inherited by all tenants. UUID tenant_id = tenant-owned report.'
    )
    op.create_index(op.f('uq_report_code_system'), 'report_master', ['report_code'], unique=True, postgresql_where='(tenant_id IS NULL)')
    op.create_index(op.f('idx_rm_tenant_category'), 'report_master', ['tenant_id', 'report_category', 'is_active'], unique=False)
    op.create_index(op.f('idx_rm_system_templates'), 'report_master', ['report_category', 'sort_order'], unique=False, postgresql_where='(tenant_id IS NULL)')
    op.create_index(op.f('idx_rm_entity'), 'report_master', ['primary_entity_id'], unique=False)
    op.create_table('menu_master',
    sa.Column('menu_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.Column('tenant_id', sa.UUID(), autoincrement=False, nullable=True),
    sa.Column('menu_code', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('display_name', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('is_active', sa.BOOLEAN(), server_default=sa.text('true'), autoincrement=False, nullable=False),
    sa.Column('created_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.PrimaryKeyConstraint('menu_id', name=op.f('pk_menu_master')),
    sa.UniqueConstraint('tenant_id', 'menu_code', name=op.f('uq_menu_code'))
    )
    op.create_table('policy_action_map',
    sa.Column('tenant_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('mapping_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.Column('policy_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('outcome', sa.TEXT(), autoincrement=False, nullable=False, comment='Policy verdict: allow | deny | require | flag.'),
    sa.Column('action_type', sa.TEXT(), autoincrement=False, nullable=False, comment='System action to execute when this outcome fires.'),
    sa.Column('action_payload', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=True),
    sa.Column('created_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.CheckConstraint("outcome = ANY (ARRAY['allow'::text, 'deny'::text, 'require'::text, 'flag'::text])", name=op.f('policy_action_map_outcome_check')),
    sa.ForeignKeyConstraint(['tenant_id', 'policy_id'], ['policy_master.tenant_id', 'policy_master.policy_id'], name=op.f('fk_pam_policy'), ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['tenant_id'], ['tenants.tenant_id'], name=op.f('policy_action_map_tenant_id_fkey'), ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('tenant_id', 'mapping_id', name=op.f('pk_policy_action_map')),
    sa.UniqueConstraint('mapping_id', name=op.f('uq_mapping_id')),
    comment='Maps policy evaluation outcomes to concrete system actions (block, notify, flag, etc.).'
    )
    op.create_table('form_fields',
    sa.Column('tenant_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('field_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.Column('section_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('attribute_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('widget_type', sa.TEXT(), server_default=sa.text("'text_input'::text"), autoincrement=False, nullable=False, comment='UI widget used to render this field (text_input, select, date_picker, etc.).'),
    sa.Column('label_override', sa.TEXT(), autoincrement=False, nullable=True, comment='Context-specific label; falls back to attribute_master.display_label if NULL.'),
    sa.Column('placeholder', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('help_text', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('is_required_override', sa.BOOLEAN(), autoincrement=False, nullable=True, comment='When not NULL, overrides the required flag from attribute_master.'),
    sa.Column('visibility_rule', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=True, comment='JSON Logic evaluated against current form state; controls conditional field show/hide.'),
    sa.Column('validation_override', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=True, comment='JSON Schema fragment that overrides the attribute-level validation only for this form.'),
    sa.Column('sort_order', sa.INTEGER(), server_default=sa.text('0'), autoincrement=False, nullable=False),
    sa.Column('created_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.ForeignKeyConstraint(['tenant_id', 'attribute_id'], ['attribute_master.tenant_id', 'attribute_master.attribute_id'], name=op.f('fk_ff_attribute'), ondelete='RESTRICT'),
    sa.ForeignKeyConstraint(['tenant_id', 'section_id'], ['form_sections.tenant_id', 'form_sections.section_id'], name=op.f('fk_ff_section'), ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['tenant_id'], ['tenants.tenant_id'], name=op.f('form_fields_tenant_id_fkey'), ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('tenant_id', 'field_id', name=op.f('pk_form_fields')),
    sa.UniqueConstraint('field_id', name=op.f('uq_field_id')),
    comment='Binds an attribute to a form section with rendering overrides. LAW 2: values go to attribute_values.'
    )
    op.create_index(op.f('idx_form_fields_section'), 'form_fields', ['tenant_id', 'section_id', 'sort_order'], unique=False)
    op.create_table('sovereign_admin_registry',
    sa.Column('admin_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.Column('display_name', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('email', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('hsm_key_fingerprint', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('is_active', sa.BOOLEAN(), server_default=sa.text('true'), autoincrement=False, nullable=False),
    sa.Column('enrolled_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.Column('enrolled_by', sa.UUID(), autoincrement=False, nullable=True),
    sa.PrimaryKeyConstraint('admin_id', name=op.f('pk_sovereign_admin_registry')),
    sa.UniqueConstraint('email', name=op.f('sovereign_admin_registry_email_key')),
    sa.UniqueConstraint('hsm_key_fingerprint', name=op.f('sovereign_admin_registry_hsm_key_fingerprint_key')),
    comment='LAW 09-2.1: Registry of platform-level Sovereign Administrators eligible to co-sign a Chain Break Event. Three active admins are required for quorum. HSM key fingerprints stored; actual keys reside in the HSM only.'
    )
    op.create_table('audit_tenant_sequence',
    sa.Column('tenant_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('last_seq', sa.BIGINT(), server_default=sa.text('0'), autoincrement=False, nullable=False, comment='Most recently assigned sequence number for this tenant. Trigger increments atomically.'),
    sa.ForeignKeyConstraint(['tenant_id'], ['tenants.tenant_id'], name=op.f('audit_tenant_sequence_tenant_id_fkey'), ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('tenant_id', name=op.f('pk_audit_tenant_sequence')),
    comment='Layer 9: Per-tenant monotonic counter backing audit_event_log.tenant_sequence_number. Row-locked by trigger to guarantee strict ordering.'
    )
    op.create_table('plugin_execution_log',
    sa.Column('tenant_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('execution_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.Column('plugin_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('actor_id', sa.UUID(), autoincrement=False, nullable=True),
    sa.Column('invocation_payload', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=True),
    sa.Column('started_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.Column('completed_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
    sa.Column('duration_ms', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('memory_peak_mb', sa.NUMERIC(precision=8, scale=2), autoincrement=False, nullable=True),
    sa.Column('api_calls_made', sa.INTEGER(), server_default=sa.text('0'), autoincrement=False, nullable=True),
    sa.Column('exit_status', sa.TEXT(), server_default=sa.text("'RUNNING'::text"), autoincrement=False, nullable=False),
    sa.Column('termination_reason', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('output_payload', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=True),
    sa.CheckConstraint("exit_status = ANY (ARRAY['RUNNING'::text, 'SUCCESS'::text, 'TIMEOUT_KILLED'::text, 'OOM_KILLED'::text, 'RATE_LIMITED'::text, 'EGRESS_BLOCKED'::text, 'FAILED'::text, 'REVOKED'::text])", name=op.f('plugin_execution_log_exit_status_check')),
    sa.ForeignKeyConstraint(['tenant_id', 'plugin_id'], ['plugin_registry.tenant_id', 'plugin_registry.plugin_id'], name=op.f('fk_pel_plugin'), ondelete='RESTRICT'),
    sa.ForeignKeyConstraint(['tenant_id'], ['tenants.tenant_id'], name=op.f('plugin_execution_log_tenant_id_fkey'), ondelete='RESTRICT'),
    sa.PrimaryKeyConstraint('tenant_id', 'execution_id', name=op.f('pk_plugin_execution_log')),
    sa.UniqueConstraint('execution_id', name=op.f('uq_execution_id'))
    )
    op.create_index(op.f('idx_pel_plugin'), 'plugin_execution_log', ['tenant_id', 'plugin_id', sa.literal_column('started_at DESC')], unique=False)
    op.create_index(op.f('idx_pel_exit'), 'plugin_execution_log', ['tenant_id', 'exit_status', sa.literal_column('started_at DESC')], unique=False)
    op.create_table('report_filters',
    sa.Column('tenant_id', sa.UUID(), autoincrement=False, nullable=True, comment='NULL for filters belonging to SYSTEM template reports.'),
    sa.Column('filter_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.Column('report_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('filter_group', sa.TEXT(), server_default=sa.text("'default'::text"), autoincrement=False, nullable=False, comment='Conditions in the same group share group_operator (AND|OR). Groups are combined with AND between them.'),
    sa.Column('group_operator', sa.TEXT(), server_default=sa.text("'AND'::text"), autoincrement=False, nullable=False),
    sa.Column('attribute_id', sa.UUID(), autoincrement=False, nullable=True),
    sa.Column('filter_source', sa.TEXT(), server_default=sa.text("'ATTRIBUTE'::text"), autoincrement=False, nullable=False, comment='Resolution strategy: ATTRIBUTE | DATE_RANGE | CONTEXT (RLS var) | EXPRESSION (JSON Logic).'),
    sa.Column('operator', sa.TEXT(), autoincrement=False, nullable=False, comment='Comparison operator: eq | ne | lt | lte | gt | gte | in | not_in | is_null | is_not_null | contains | starts_with | matches_regex.'),
    sa.Column('static_value', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=True, comment='Typed JSONB value baked into the definition. NULL for user-facing filters where value is supplied at runtime.'),
    sa.Column('context_key', sa.TEXT(), autoincrement=False, nullable=True, comment='For CONTEXT source: runtime variable name e.g. CURRENT_TENANT | CURRENT_USER | CURRENT_SCHOOL.'),
    sa.Column('expression_dsl', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=True),
    sa.Column('is_user_facing', sa.BOOLEAN(), server_default=sa.text('false'), autoincrement=False, nullable=False, comment='TRUE = shown in the UI filter panel; user supplies value at runtime. FALSE = hidden, always applied automatically.'),
    sa.Column('ui_label', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('ui_input_type', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('is_required', sa.BOOLEAN(), server_default=sa.text('false'), autoincrement=False, nullable=False, comment='TRUE = report engine blocks execution until user provides a value for this filter.'),
    sa.Column('sort_order', sa.INTEGER(), server_default=sa.text('0'), autoincrement=False, nullable=False),
    sa.Column('is_active', sa.BOOLEAN(), server_default=sa.text('true'), autoincrement=False, nullable=False),
    sa.CheckConstraint("filter_source = ANY (ARRAY['ATTRIBUTE'::text, 'DATE_RANGE'::text, 'CONTEXT'::text, 'EXPRESSION'::text])", name=op.f('report_filters_filter_source_check')),
    sa.CheckConstraint("group_operator = ANY (ARRAY['AND'::text, 'OR'::text])", name=op.f('report_filters_group_operator_check')),
    sa.CheckConstraint("ui_input_type = ANY (ARRAY['TEXT'::text, 'NUMBER'::text, 'DATE'::text, 'DATE_RANGE'::text, 'DROPDOWN'::text, 'MULTI_SELECT'::text, 'BOOLEAN'::text, NULL::text])", name=op.f('report_filters_ui_input_type_check')),
    sa.ForeignKeyConstraint(['attribute_id'], ['attribute_master.attribute_id'], name=op.f('fk_rf_attribute'), ondelete='RESTRICT'),
    sa.ForeignKeyConstraint(['report_id'], ['report_master.report_id'], name=op.f('fk_rf_report'), ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('filter_id', name=op.f('pk_report_filters')),
    comment='Layer 10 / LAW 9: Structured WHERE-clause predicate definitions. No raw SQL stored. Static or user-facing runtime values resolved by the report engine.'
    )
    op.create_index(op.f('idx_rf_user_facing'), 'report_filters', ['report_id', 'is_user_facing'], unique=False, postgresql_where='(is_user_facing = true)')
    op.create_index(op.f('idx_rf_report'), 'report_filters', ['report_id', 'filter_group', 'sort_order'], unique=False)
    op.create_table('tenant_shard_config',
    sa.Column('tenant_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('shard_id', sa.TEXT(), server_default=sa.text("'shard-01'::text"), autoincrement=False, nullable=False),
    sa.Column('api_quota_per_minute', sa.INTEGER(), server_default=sa.text('1000'), autoincrement=False, nullable=False),
    sa.Column('write_quota_per_minute', sa.INTEGER(), server_default=sa.text('100'), autoincrement=False, nullable=False),
    sa.Column('emergency_cap_pct', sa.NUMERIC(precision=5, scale=2), server_default=sa.text('20.0'), autoincrement=False, nullable=False),
    sa.Column('circuit_breaker_status', sa.TEXT(), server_default=sa.text("'CLOSED'::text"), autoincrement=False, nullable=False),
    sa.Column('circuit_breaker_opened_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
    sa.Column('circuit_breaker_reason', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('contracted_tier', sa.TEXT(), server_default=sa.text("'STANDARD'::text"), autoincrement=False, nullable=False),
    sa.Column('effective_from', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.Column('shard_capacity_pct', sa.NUMERIC(precision=5, scale=2), server_default=sa.text('0.0'), autoincrement=False, nullable=False),
    sa.Column('notes', sa.TEXT(), autoincrement=False, nullable=True),
    sa.CheckConstraint("circuit_breaker_status = ANY (ARRAY['CLOSED'::text, 'THROTTLED'::text, 'OPEN'::text])", name=op.f('tenant_shard_config_circuit_breaker_status_check')),
    sa.CheckConstraint("contracted_tier = ANY (ARRAY['STARTER'::text, 'STANDARD'::text, 'ENTERPRISE'::text, 'UNLIMITED'::text])", name=op.f('tenant_shard_config_contracted_tier_check')),
    sa.CheckConstraint('api_quota_per_minute > 0', name=op.f('tenant_shard_config_api_quota_per_minute_check')),
    sa.CheckConstraint('emergency_cap_pct >= 1.0 AND emergency_cap_pct <= 100.0', name=op.f('tenant_shard_config_emergency_cap_pct_check')),
    sa.CheckConstraint('write_quota_per_minute > 0', name=op.f('tenant_shard_config_write_quota_per_minute_check')),
    sa.ForeignKeyConstraint(['tenant_id'], ['tenants.tenant_id'], name=op.f('tenant_shard_config_tenant_id_fkey'), ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('tenant_id', name=op.f('pk_tenant_shard_config')),
    comment='LAW 09-4.1 to 09-4.4: Per-tenant API quota configuration and shard assignment. api_quota_per_minute enforced by API gateway middleware. circuit_breaker_status managed by fn_check_circuit_breaker().'
    )
    op.create_table('chain_break_events',
    sa.Column('cbe_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.Column('tenant_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('declaration_reason', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('broken_from_seq', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('last_valid_seq', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('last_valid_hash', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('worm_checkpoint_ref', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('declared_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.Column('quorum_reached_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
    sa.Column('recovery_sentinel_log_id', sa.UUID(), autoincrement=False, nullable=True),
    sa.Column('status', sa.TEXT(), server_default=sa.text("'PENDING_QUORUM'::text"), autoincrement=False, nullable=False),
    sa.CheckConstraint("status = ANY (ARRAY['PENDING_QUORUM'::text, 'QUORUM_REACHED'::text, 'SEALED'::text, 'REJECTED'::text])", name=op.f('chain_break_events_status_check')),
    sa.ForeignKeyConstraint(['tenant_id'], ['tenants.tenant_id'], name=op.f('chain_break_events_tenant_id_fkey'), ondelete='RESTRICT'),
    sa.PrimaryKeyConstraint('cbe_id', name=op.f('pk_chain_break_events')),
    comment='LAW 09-2.1: One row per Chain Break Event declaration. status=SEALED only after 3-of-3 sovereign admin signatures AND the CHAIN_BREAK_RECOVERY sentinel is appended to the audit chain.'
    )
    op.create_table('residency_violation_log',
    sa.Column('log_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.Column('tenant_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('expected_region', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('detected_region', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('data_store_identifier', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('record_count_estimate', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('detected_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.Column('quarantine_action', sa.TEXT(), server_default=sa.text("'PENDING'::text"), autoincrement=False, nullable=False),
    sa.Column('dpo_notified_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
    sa.Column('resolution_notes', sa.TEXT(), autoincrement=False, nullable=True),
    sa.CheckConstraint("quarantine_action = ANY (ARRAY['PENDING'::text, 'QUARANTINED'::text, 'DELETED'::text, 'ESCALATED'::text])", name=op.f('residency_violation_log_quarantine_action_check')),
    sa.ForeignKeyConstraint(['tenant_id'], ['tenants.tenant_id'], name=op.f('residency_violation_log_tenant_id_fkey'), ondelete='RESTRICT'),
    sa.PrimaryKeyConstraint('log_id', name=op.f('pk_residency_violation_log')),
    comment='LAW 09-6.3: INSERT-ONLY log of unauthorized geographic data transfers detected by the 24-hour residency sentinel. dpo_notified_at must be set within 1 hour of detection per DPDP Act breach notification requirements.'
    )
    op.create_table('tenant_settings',
    sa.Column('tenant_id', sa.UUID(), autoincrement=False, nullable=False, comment='Tenant that owns this setting.'),
    sa.Column('setting_key', sa.TEXT(), autoincrement=False, nullable=False, comment='Namespaced key (e.g. "auth.mfa_required", "grading.passing_threshold").'),
    sa.Column('setting_value', sa.TEXT(), autoincrement=False, nullable=False, comment='JSON-serialised value. Interpret based on the key convention.'),
    sa.Column('description', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('updated_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.Column('updated_by', sa.UUID(), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['tenant_id'], ['tenants.tenant_id'], name=op.f('tenant_settings_tenant_id_fkey'), ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('tenant_id', 'setting_key', name=op.f('pk_tenant_settings')),
    comment='Per-tenant configuration key-value store. Implements LAW 5: Settings decide DEFAULT values.'
    )
    op.create_table('report_role_access',
    sa.Column('tenant_id', sa.UUID(), autoincrement=False, nullable=True, comment='NULL for access rules on SYSTEM template reports that apply to all tenants.'),
    sa.Column('access_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.Column('report_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('role_code', sa.TEXT(), autoincrement=False, nullable=False, comment='Role identifier matching application RBAC definitions: SUPER_ADMIN | SCHOOL_ADMIN | TEACHER | STUDENT | PARENT | custom.'),
    sa.Column('can_view', sa.BOOLEAN(), server_default=sa.text('true'), autoincrement=False, nullable=False, comment='TRUE = role may see on-screen results.'),
    sa.Column('can_export', sa.BOOLEAN(), server_default=sa.text('false'), autoincrement=False, nullable=False, comment='TRUE = role may download in allowed export_formats. Overrides is_exportable for this role.'),
    sa.Column('max_rows_override', sa.INTEGER(), autoincrement=False, nullable=True, comment='Overrides report_master.max_rows for this specific role. NULL = use the report default.'),
    sa.Column('row_filter_policy_id', sa.UUID(), autoincrement=False, nullable=True, comment='Optional policy_master FK whose conditions are appended as additional WHERE predicates for rows visible to this role.'),
    sa.Column('created_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.ForeignKeyConstraint(['report_id'], ['report_master.report_id'], name=op.f('fk_rra_report'), ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['tenant_id', 'row_filter_policy_id'], ['policy_master.tenant_id', 'policy_master.policy_id'], name=op.f('fk_rra_row_filter_policy'), ondelete='SET NULL'),
    sa.PrimaryKeyConstraint('access_id', name=op.f('pk_report_role_access')),
    sa.UniqueConstraint('report_id', 'role_code', 'tenant_id', name=op.f('uq_report_role')),
    comment='Layer 10 / LAW 9: RBAC control for report VIEW and EXPORT. Access decisions are data rows ??? no if(role==) in code. LAW 4: policy engine evaluates before execution.'
    )
    op.create_index(op.f('idx_rra_role'), 'report_role_access', ['role_code', 'can_view'], unique=False)
    op.create_index(op.f('idx_rra_report_role'), 'report_role_access', ['report_id', 'role_code'], unique=False)
    op.create_table('security_event_log',
    sa.Column('tenant_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('log_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.Column('event_type', sa.TEXT(), autoincrement=False, nullable=False, comment='Screaming-snake security event descriptor: AUTH_LOGIN_SUCCESS | AUTHZ_DENIED | MFA_FAILURE | ANOMALY_DETECTED | RATE_LIMIT_EXCEEDED | etc.'),
    sa.Column('severity', sa.TEXT(), server_default=sa.text("'INFO'::text"), autoincrement=False, nullable=False, comment='Log severity level: DEBUG | INFO | WARN | ERROR | CRITICAL.'),
    sa.Column('actor_id', sa.UUID(), autoincrement=False, nullable=True),
    sa.Column('actor_type', sa.TEXT(), server_default=sa.text("'USER'::text"), autoincrement=False, nullable=False),
    sa.Column('ip_address_hash', sa.TEXT(), autoincrement=False, nullable=True, comment='SHA-256 of the actor IP address. Raw IP is NEVER stored (privacy compliance).'),
    sa.Column('user_agent_hash', sa.TEXT(), autoincrement=False, nullable=True, comment='SHA-256 of the raw User-Agent string. Enables fingerprinting without PII storage.'),
    sa.Column('session_id', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('resource_path', sa.TEXT(), autoincrement=False, nullable=True, comment='API or logical resource being accessed. No query parameters or PII in this column.'),
    sa.Column('policy_id', sa.UUID(), autoincrement=False, nullable=True, comment='FK to policy_master when a policy evaluation produced this security event.'),
    sa.Column('decision', sa.TEXT(), autoincrement=False, nullable=True, comment='Access decision: ALLOW | DENY | CHALLENGE. NULL for informational / audit-only events.'),
    sa.Column('event_data', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=True),
    sa.Column('correlation_id', sa.TEXT(), autoincrement=False, nullable=True, comment='Distributed tracing ID. Correlates this event with APM spans and audit_event_log entries.'),
    sa.Column('logged_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.CheckConstraint("decision = ANY (ARRAY['ALLOW'::text, 'DENY'::text, 'CHALLENGE'::text, NULL::text])", name=op.f('security_event_log_decision_check')),
    sa.CheckConstraint("severity = ANY (ARRAY['DEBUG'::text, 'INFO'::text, 'WARN'::text, 'ERROR'::text, 'CRITICAL'::text])", name=op.f('security_event_log_severity_check')),
    sa.ForeignKeyConstraint(['tenant_id', 'policy_id'], ['policy_master.tenant_id', 'policy_master.policy_id'], name=op.f('fk_sel_policy'), ondelete='SET NULL'),
    sa.ForeignKeyConstraint(['tenant_id'], ['tenants.tenant_id'], name=op.f('security_event_log_tenant_id_fkey'), ondelete='RESTRICT'),
    sa.PrimaryKeyConstraint('tenant_id', 'log_id', name=op.f('pk_security_event_log')),
    sa.UniqueConstraint('log_id', name=op.f('uq_security_log_id')),
    comment='Layer 9 / LAW 8: INSERT-ONLY dedicated security event log for auth, authz, and anomaly events. Separated from audit_event_log for SIEM integration and high-volume indexing.'
    )
    op.create_index(op.f('idx_sel_severity'), 'security_event_log', ['tenant_id', 'severity', sa.literal_column('logged_at DESC')], unique=False, postgresql_where="(severity = ANY (ARRAY['WARN'::text, 'ERROR'::text, 'CRITICAL'::text]))")
    op.create_index(op.f('idx_sel_session'), 'security_event_log', ['tenant_id', 'session_id'], unique=False, postgresql_where='(session_id IS NOT NULL)')
    op.create_index(op.f('idx_sel_policy'), 'security_event_log', ['tenant_id', 'policy_id'], unique=False, postgresql_where='(policy_id IS NOT NULL)')
    op.create_index(op.f('idx_sel_event_type'), 'security_event_log', ['tenant_id', 'event_type', sa.literal_column('logged_at DESC')], unique=False)
    op.create_index(op.f('idx_sel_actor'), 'security_event_log', ['tenant_id', 'actor_id', sa.literal_column('logged_at DESC')], unique=False, postgresql_where='(actor_id IS NOT NULL)')
    op.create_table('menu_items',
    sa.Column('item_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.Column('tenant_id', sa.UUID(), autoincrement=False, nullable=True),
    sa.Column('menu_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('parent_item_id', sa.UUID(), autoincrement=False, nullable=True),
    sa.Column('label', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('icon_name', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('route_path', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('action_type', sa.TEXT(), server_default=sa.text("'ROUTE'::text"), autoincrement=False, nullable=False),
    sa.Column('action_target', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('required_roles', postgresql.ARRAY(sa.TEXT()), server_default=sa.text("'{}'::text[]"), autoincrement=False, nullable=False),
    sa.Column('sort_order', sa.INTEGER(), server_default=sa.text('0'), autoincrement=False, nullable=False),
    sa.Column('is_active', sa.BOOLEAN(), server_default=sa.text('true'), autoincrement=False, nullable=False),
    sa.CheckConstraint("action_type = ANY (ARRAY['ROUTE'::text, 'REPORT'::text, 'FORM'::text, 'URL'::text, 'DIVIDER'::text])", name=op.f('menu_items_action_type_check')),
    sa.ForeignKeyConstraint(['menu_id'], ['menu_master.menu_id'], name=op.f('menu_items_menu_id_fkey'), ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['parent_item_id'], ['menu_items.item_id'], name=op.f('menu_items_parent_item_id_fkey'), ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('item_id', name=op.f('pk_menu_items')),
    sa.UniqueConstraint('tenant_id', 'menu_id', 'label', name=op.f('uq_menu_item'))
    )
    op.create_index(op.f('idx_menu_items_nav'), 'menu_items', ['menu_id', 'parent_item_id', 'sort_order'], unique=False)
    op.create_table('entity_attribute_values',
    sa.Column('tenant_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('value_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.Column('record_id', sa.UUID(), autoincrement=False, nullable=False, comment='FK to entity_records identifying the specific entity instance.'),
    sa.Column('attribute_id', sa.UUID(), autoincrement=False, nullable=False, comment='FK to attribute_master identifying the field whose value this row stores.'),
    sa.Column('value_text', sa.TEXT(), autoincrement=False, nullable=True, comment='Value for data_type = text | file | date | json (as string).'),
    sa.Column('value_number', sa.NUMERIC(), autoincrement=False, nullable=True, comment='Value for data_type = number (integer or decimal, full precision).'),
    sa.Column('value_bool', sa.BOOLEAN(), autoincrement=False, nullable=True, comment='Value for data_type = boolean.'),
    sa.Column('value_jsonb', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=True, comment='Value for data_type = json when structured traversal is needed (preferred over value_text for JSON).'),
    sa.Column('source', sa.TEXT(), server_default=sa.text("'user_input'::text"), autoincrement=False, nullable=False, comment='Provenance: user_input | system_computed | import | api | default.'),
    sa.Column('version', sa.INTEGER(), server_default=sa.text('1'), autoincrement=False, nullable=False, comment='Optimistic concurrency counter; incremented on each write.'),
    sa.Column('created_by', sa.UUID(), autoincrement=False, nullable=True),
    sa.Column('created_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.Column('updated_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.ForeignKeyConstraint(['tenant_id', 'attribute_id'], ['attribute_master.tenant_id', 'attribute_master.attribute_id'], name=op.f('fk_eav_attribute'), ondelete='RESTRICT'),
    sa.ForeignKeyConstraint(['tenant_id', 'record_id'], ['entity_records.tenant_id', 'entity_records.record_id'], name=op.f('fk_eav_record'), ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['tenant_id'], ['tenants.tenant_id'], name=op.f('entity_attribute_values_tenant_id_fkey'), ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('tenant_id', 'value_id', name=op.f('pk_entity_attribute_values')),
    sa.UniqueConstraint('tenant_id', 'record_id', 'attribute_id', name=op.f('uq_eav_record_attribute')),
    sa.UniqueConstraint('value_id', name=op.f('uq_eav_value_id')),
    comment='Layer 6: The canonical EAV value store. ALL runtime entity field data lives here. LAW 2 enforcement. LAW 10: no grade/rank/pass-fail columns.'
    )
    op.create_index(op.f('idx_eav_record'), 'entity_attribute_values', ['tenant_id', 'record_id'], unique=False)
    op.create_index(op.f('idx_eav_attribute_record'), 'entity_attribute_values', ['tenant_id', 'attribute_id', 'record_id'], unique=False)
    op.create_table('cbe_quorum_signatures',
    sa.Column('signature_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.Column('cbe_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('admin_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('hsm_signature', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('signed_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.Column('signature_verified', sa.BOOLEAN(), server_default=sa.text('false'), autoincrement=False, nullable=False),
    sa.ForeignKeyConstraint(['admin_id'], ['sovereign_admin_registry.admin_id'], name=op.f('cbe_quorum_signatures_admin_id_fkey')),
    sa.ForeignKeyConstraint(['cbe_id'], ['chain_break_events.cbe_id'], name=op.f('cbe_quorum_signatures_cbe_id_fkey'), ondelete='RESTRICT'),
    sa.PrimaryKeyConstraint('signature_id', name=op.f('pk_cbe_quorum_signatures')),
    sa.UniqueConstraint('cbe_id', 'admin_id', name=op.f('uq_cbe_admin_signature')),
    comment='LAW 09-2.1: Captures the individual HSM co-signatures for a Chain Break Event. Quorum is reached when 3 rows for the same cbe_id have signature_verified=TRUE. An admin may sign a given CBE exactly once (UNIQUE constraint).'
    )
    op.create_table('policy_actions',
    sa.Column('tenant_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('action_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.Column('policy_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('outcome', sa.TEXT(), autoincrement=False, nullable=False, comment='The policy verdict that triggers this action: allow | deny | require | flag | escalate | notify.'),
    sa.Column('action_type', sa.TEXT(), autoincrement=False, nullable=False, comment='Enum of typed system actions: BLOCK_TRANSITION | SEND_NOTIFICATION | CREATE_TASK | SET_ATTRIBUTE_VALUE | START_WORKFLOW | LOG_AUDIT_EVENT | CALL_WEBHOOK.'),
    sa.Column('action_payload', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=False, comment='Structured JSON argument bag specific to action_type. No raw SQL or template strings. E.g. {template_code: "approval_needed", recipients: ["REVIEWER"]}.'),
    sa.Column('priority', sa.INTEGER(), server_default=sa.text('100'), autoincrement=False, nullable=False, comment='Execution order when multiple actions share the same outcome; lower = first.'),
    sa.Column('is_active', sa.BOOLEAN(), server_default=sa.text('true'), autoincrement=False, nullable=False),
    sa.Column('created_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.CheckConstraint("outcome = ANY (ARRAY['allow'::text, 'deny'::text, 'require'::text, 'flag'::text, 'escalate'::text, 'notify'::text])", name=op.f('policy_actions_outcome_check')),
    sa.ForeignKeyConstraint(['tenant_id', 'policy_id'], ['policy_master.tenant_id', 'policy_master.policy_id'], name=op.f('fk_pa_policy'), ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['tenant_id'], ['tenants.tenant_id'], name=op.f('policy_actions_tenant_id_fkey'), ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('tenant_id', 'action_id', name=op.f('pk_policy_actions')),
    sa.UniqueConstraint('action_id', name=op.f('uq_policy_action_id')),
    comment='Layer 5: Typed effects that fire when a policy produces a given outcome. Richer replacement for Layer 2 policy_action_map.'
    )
    op.create_index(op.f('idx_paction_policy'), 'policy_actions', ['tenant_id', 'policy_id', 'outcome', 'priority'], unique=False)
    op.create_table('ai_tasks',
    sa.Column('tenant_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('task_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.Column('model_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('task_type', sa.TEXT(), autoincrement=False, nullable=False, comment='Descriptor of the AI operation: QUESTION_GENERATION | ESSAY_EVALUATION | TRANSCRIPT_SUMMARY | EMBEDDING | CONTENT_MODERATION | TUTORING_RESPONSE | CUSTOM.'),
    sa.Column('source_record_id', sa.UUID(), autoincrement=False, nullable=True, comment='UUID of the entity_records row that triggered this task, enabling result linkage.'),
    sa.Column('source_entity_id', sa.UUID(), autoincrement=False, nullable=True),
    sa.Column('initiated_by', sa.UUID(), autoincrement=False, nullable=True),
    sa.Column('workflow_instance_id', sa.UUID(), autoincrement=False, nullable=True, comment="FK to workflow_instance_state that governs this task's QUEUED???RUNNING???DONE lifecycle."),
    sa.Column('input_payload', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=False, comment='Structured JSONB prompt/input to the model. No raw text strings (LAW 9).'),
    sa.Column('output_payload', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=True, comment='Structured JSONB response from the model. NULL until completed. LAW 10: no score/grade columns.'),
    sa.Column('token_usage', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=True, comment='JSONB token accounting: {input_tokens, output_tokens, total_tokens}.'),
    sa.Column('cost_usd', sa.NUMERIC(precision=12, scale=6), autoincrement=False, nullable=True, comment='Billed cost in USD. NULL until confirmed by provider. Used for tenant cost reporting.'),
    sa.Column('error_payload', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=True),
    sa.Column('retry_count', sa.INTEGER(), server_default=sa.text('0'), autoincrement=False, nullable=False),
    sa.Column('max_retries', sa.INTEGER(), server_default=sa.text('3'), autoincrement=False, nullable=False),
    sa.Column('priority', sa.INTEGER(), server_default=sa.text('50'), autoincrement=False, nullable=False, comment='Queue priority: 0 = highest, 100 = lowest. Scheduler orders by (priority, queued_at).'),
    sa.Column('queued_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.Column('started_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
    sa.Column('completed_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
    sa.Column('metadata', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['tenant_id', 'model_id'], ['ai_model_registry.tenant_id', 'ai_model_registry.model_id'], name=op.f('fk_at_model'), ondelete='RESTRICT'),
    sa.ForeignKeyConstraint(['tenant_id', 'workflow_instance_id'], ['workflow_instance_state.tenant_id', 'workflow_instance_state.instance_id'], name=op.f('fk_at_workflow_instance'), ondelete='SET NULL'),
    sa.ForeignKeyConstraint(['tenant_id'], ['tenants.tenant_id'], name=op.f('ai_tasks_tenant_id_fkey'), ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('tenant_id', 'task_id', name=op.f('pk_ai_tasks')),
    sa.UniqueConstraint('task_id', name=op.f('uq_ai_task_id')),
    comment='Layer 7: Every AI inference request and async AI job. Lifecycle managed by Layer 4 workflow. LAW 3: no if(status==) ??? transitions drive state. LAW 10: no scores stored.'
    )
    op.create_index(op.f('idx_at_workflow_instance'), 'ai_tasks', ['tenant_id', 'workflow_instance_id'], unique=False, postgresql_where='(workflow_instance_id IS NOT NULL)')
    op.create_index(op.f('idx_at_source_record'), 'ai_tasks', ['tenant_id', 'source_record_id'], unique=False, postgresql_where='(source_record_id IS NOT NULL)')
    op.create_index(op.f('idx_at_queued'), 'ai_tasks', ['tenant_id', 'priority', 'queued_at'], unique=False, postgresql_where='(completed_at IS NULL)')
    op.create_index(op.f('idx_at_model'), 'ai_tasks', ['tenant_id', 'model_id'], unique=False)
    op.create_table('plugin_registry',
    sa.Column('tenant_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('plugin_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.Column('plugin_code', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('display_name', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('vendor', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('version', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('max_execution_ms', sa.INTEGER(), server_default=sa.text('5000'), autoincrement=False, nullable=False),
    sa.Column('max_memory_mb', sa.INTEGER(), server_default=sa.text('256'), autoincrement=False, nullable=False),
    sa.Column('max_api_calls_per_min', sa.INTEGER(), server_default=sa.text('100'), autoincrement=False, nullable=False),
    sa.Column('allowed_egress_hosts', postgresql.ARRAY(sa.TEXT()), server_default=sa.text("'{}'::text[]"), autoincrement=False, nullable=False),
    sa.Column('vlan_id', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('blast_radius_score', sa.NUMERIC(precision=3, scale=1), server_default=sa.text('0.0'), autoincrement=False, nullable=False),
    sa.Column('architect_approved', sa.BOOLEAN(), server_default=sa.text('false'), autoincrement=False, nullable=False),
    sa.Column('approved_by', sa.UUID(), autoincrement=False, nullable=True),
    sa.Column('approved_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
    sa.Column('status', sa.TEXT(), server_default=sa.text("'PENDING_REVIEW'::text"), autoincrement=False, nullable=False),
    sa.Column('installed_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.Column('suspended_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
    sa.Column('suspension_reason', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('metadata', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=True),
    sa.CheckConstraint("status = ANY (ARRAY['PENDING_REVIEW'::text, 'APPROVED'::text, 'SUSPENDED'::text, 'REVOKED'::text])", name=op.f('plugin_registry_status_check')),
    sa.CheckConstraint('blast_radius_score >= 0.0 AND blast_radius_score <= 10.0', name=op.f('plugin_registry_blast_radius_score_check')),
    sa.ForeignKeyConstraint(['tenant_id'], ['tenants.tenant_id'], name=op.f('plugin_registry_tenant_id_fkey'), ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('tenant_id', 'plugin_id', name=op.f('pk_plugin_registry')),
    sa.UniqueConstraint('plugin_id', name=op.f('uq_plugin_id')),
    sa.UniqueConstraint('tenant_id', 'plugin_code', name=op.f('uq_plugin_code')),
    comment='LAW 09-3.1 to 09-3.5: Per-tenant registry of third-party plugins. Resource limits (execution_ms, memory_mb, api_calls) are kernel-enforced. Plugins with blast_radius_score > 7.0 require architect_approved=TRUE before activation.'
    )
    op.create_table('policy_evaluation_log',
    sa.Column('tenant_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('log_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.Column('policy_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('record_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('actor_id', sa.UUID(), autoincrement=False, nullable=True),
    sa.Column('context_snapshot', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=False, comment='JSONB snapshot of attribute values visible to the engine at evaluation time. Immutable.'),
    sa.Column('outcome', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('conditions_result', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=True, comment='Per-condition pass/fail breakdown as JSONB, enabling granular audit.'),
    sa.Column('evaluated_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.CheckConstraint("outcome = ANY (ARRAY['allow'::text, 'deny'::text, 'require'::text, 'flag'::text, 'escalate'::text, 'notify'::text])", name=op.f('policy_evaluation_log_outcome_check')),
    sa.ForeignKeyConstraint(['tenant_id', 'policy_id'], ['policy_master.tenant_id', 'policy_master.policy_id'], name=op.f('fk_pel_policy'), ondelete='RESTRICT'),
    sa.ForeignKeyConstraint(['tenant_id'], ['tenants.tenant_id'], name=op.f('policy_evaluation_log_tenant_id_fkey'), ondelete='RESTRICT'),
    sa.PrimaryKeyConstraint('tenant_id', 'log_id', name=op.f('pk_policy_evaluation_log')),
    sa.UniqueConstraint('log_id', name=op.f('uq_policy_log_id')),
    comment='Layer 5 / LAW 8: INSERT-ONLY log of every policy evaluation. Used for audit trails and explainability ("why was I denied?").'
    )
    op.create_index(op.f('idx_pel_record'), 'policy_evaluation_log', ['tenant_id', 'record_id', sa.literal_column('evaluated_at DESC')], unique=False)
    op.create_index(op.f('idx_pel_policy_record'), 'policy_evaluation_log', ['tenant_id', 'policy_id', 'record_id', sa.literal_column('evaluated_at DESC')], unique=False)
    op.create_table('report_dimensions',
    sa.Column('tenant_id', sa.UUID(), autoincrement=False, nullable=True, comment='NULL for dimensions belonging to SYSTEM template reports. UUID for tenant-owned report dimensions.'),
    sa.Column('dimension_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.Column('report_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('attribute_id', sa.UUID(), autoincrement=False, nullable=True, comment='FK to attribute_master. The report engine resolves the physical column from here. NULL when dimension_source = EXPRESSION.'),
    sa.Column('dimension_source', sa.TEXT(), server_default=sa.text("'ATTRIBUTE'::text"), autoincrement=False, nullable=False, comment='Resolution strategy: ATTRIBUTE (from attribute_master) | DATE_TRUNC (time bucket) | EXPRESSION (structured JSON Logic DSL).'),
    sa.Column('date_trunc_unit', sa.TEXT(), autoincrement=False, nullable=True, comment='Time bucket granularity: DAY | WEEK | MONTH | QUARTER | YEAR. Used only when dimension_source = DATE_TRUNC.'),
    sa.Column('expression_dsl', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=True, comment='Structured JSON Logic expression ??? used only when dimension_source = EXPRESSION. No raw SQL ever stored here (LAW 9).'),
    sa.Column('display_label', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('is_pivotable', sa.BOOLEAN(), server_default=sa.text('false'), autoincrement=False, nullable=False, comment='When TRUE this dimension can become the horizontal header axis in PIVOT report_query_type runs.'),
    sa.Column('sort_order', sa.INTEGER(), server_default=sa.text('0'), autoincrement=False, nullable=False),
    sa.Column('is_active', sa.BOOLEAN(), server_default=sa.text('true'), autoincrement=False, nullable=False),
    sa.CheckConstraint("date_trunc_unit = ANY (ARRAY['DAY'::text, 'WEEK'::text, 'MONTH'::text, 'QUARTER'::text, 'YEAR'::text])", name=op.f('report_dimensions_date_trunc_unit_check')),
    sa.CheckConstraint("dimension_source = ANY (ARRAY['ATTRIBUTE'::text, 'DATE_TRUNC'::text, 'EXPRESSION'::text])", name=op.f('report_dimensions_dimension_source_check')),
    sa.ForeignKeyConstraint(['attribute_id'], ['attribute_master.attribute_id'], name=op.f('fk_rd_attribute'), ondelete='RESTRICT'),
    sa.ForeignKeyConstraint(['report_id'], ['report_master.report_id'], name=op.f('fk_rd_report'), ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('dimension_id', name=op.f('pk_report_dimensions')),
    comment='Layer 10 / LAW 9: GROUP BY / row-axis column definitions for a report. Resolved via attribute_master ??? no hard-coded column names.'
    )
    op.create_index(op.f('idx_rdim_report'), 'report_dimensions', ['report_id', 'sort_order'], unique=False)
    op.create_index(op.f('idx_rdim_attribute'), 'report_dimensions', ['attribute_id'], unique=False, postgresql_where='(attribute_id IS NOT NULL)')
    op.create_table('workflow_transitions',
    sa.Column('tenant_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('transition_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.Column('workflow_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('from_state', sa.TEXT(), autoincrement=False, nullable=True, comment='State the entity must be in for this transition to be allowed.'),
    sa.Column('to_state', sa.TEXT(), autoincrement=False, nullable=False, comment='State the entity will be in after a successful transition.'),
    sa.Column('trigger_event', sa.TEXT(), autoincrement=False, nullable=False, comment='Named event that activates this edge (e.g. SUBMIT, APPROVE, REJECT).'),
    sa.Column('display_label', sa.TEXT(), autoincrement=False, nullable=True, comment='Label shown on the UI button for this transition.'),
    sa.Column('guard_policy_id', sa.UUID(), autoincrement=False, nullable=True, comment='Policy evaluated BEFORE the transition; transition is blocked if policy returns deny.'),
    sa.Column('actor_roles', postgresql.ARRAY(sa.TEXT()), autoincrement=False, nullable=True, comment='Array of role codes authorised to fire this event.'),
    sa.Column('sort_order', sa.INTEGER(), server_default=sa.text('0'), autoincrement=False, nullable=False),
    sa.Column('created_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.ForeignKeyConstraint(['tenant_id', 'guard_policy_id'], ['policy_master.tenant_id', 'policy_master.policy_id'], name=op.f('fk_wt_guard'), ondelete='SET NULL'),
    sa.ForeignKeyConstraint(['tenant_id', 'workflow_id'], ['workflow_master.tenant_id', 'workflow_master.workflow_id'], name=op.f('fk_wt_workflow'), ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['tenant_id'], ['tenants.tenant_id'], name=op.f('workflow_transitions_tenant_id_fkey'), ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('tenant_id', 'transition_id', name=op.f('pk_workflow_transitions')),
    sa.UniqueConstraint('transition_id', name=op.f('uq_transition_id')),
    comment='LAW 3: Each row is one valid state-machine edge. Code fires events; engine resolves transitions.'
    )
    op.create_index(op.f('idx_wt_workflow_from'), 'workflow_transitions', ['tenant_id', 'workflow_id', 'from_state'], unique=False)
    op.drop_table('audit_logs')
    op.drop_index(op.f('ix_users_email'), table_name='users')
    op.drop_table('users')
    # ### end Alembic commands ###
